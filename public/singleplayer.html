<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>History Bowl</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
        
        <!-- Firebase SDKs -->
        <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8157883892351581"
     crossorigin="anonymous"></script>
        <script>
        // Wait for Firebase SDKs to load
        window.onload = async function() {
            try {
                // Fetch Firebase config from server
                const response = await fetch('/api/firebase-config');
                const firebaseConfig = await response.json();
                
                // Initialize Firebase
                firebase.initializeApp(firebaseConfig);

                // Make Firebase services available globally
                window.auth = firebase.auth();
                window.db = firebase.database();

                console.log('Firebase initialized');
                window.auth.onAuthStateChanged(async (user) => {
                    const authButton = document.getElementById('authButton');
                    const userStats = document.getElementById('userStats');
                    const usernameDisplay = document.getElementById('usernameDisplay');
                    
                    if (user) {
                        authButton.textContent = 'Sign Out';
                        userStats.style.display = 'block';
                        
                        // Listen for realtime updates of stats only
                        const userRef = window.db.ref('users/' + user.uid);
                        userRef.on('value', (snapshot) => {
                            const userData = snapshot.val() || { 
                                progress: { correctAnswers: 0, questionsAnswered: 0 },
                                username: 'User'
                            };
                            
                            // Update stats display
                            document.getElementById('correctCount').textContent = userData.progress?.correctAnswers || 0;
                            document.getElementById('totalCount').textContent = userData.progress?.questionsAnswered || 0;
                            
                            // Update username display
                            if (usernameDisplay) {
                                usernameDisplay.textContent = userData.username || 'User';
                            }
                        });
                    } else {
                        authButton.textContent = 'Sign In';
                        userStats.style.display = 'none';
                        if (usernameDisplay) {
                            usernameDisplay.textContent = '';
                        }
                    }
                });
            } catch (error) {
                console.error('Error initializing Firebase:', error);
            }
        };

        // Firebase helper functions
        async function loadUserProgress(userId) {
            try {
                const userRef = window.db.ref('users/' + userId);
                const snapshot = await userRef.once('value');
                const data = snapshot.val();
                
                if (data?.progress?.history) {
                    const historyDiv = document.getElementById('questionHistory');
                    historyDiv.style.display = 'block';  // Make sure history is visible
                    historyDiv.innerHTML = '';  // Clear existing history
                    
                    // Add each history entry as a card
                    data.progress.history.forEach(entry => {
                        const card = document.createElement('div');
                        card.className = `history-card ${entry.isCorrect ? 'correct' : 'incorrect'}`;
                        
                        card.innerHTML = `
                            <div class="question-text">${entry.question}</div>
                            <div class="answer-section">
                                <div>
                                    <span class="user-answer">Your answer: ${entry.userAnswer}</span>
                                </div>
                                <div>
                                    <span class="correct-answer">Correct answer: ${entry.answer.replace(/<\/?[^>]+(>|$)/g, '')}</span>
                                </div>
                            </div>
                        `;
                        
                        historyDiv.appendChild(card);
                    });
                }
            } catch (error) {
                console.error("Error loading progress:", error);
            }
        }

        async function saveUserProgress(questionData) {
    const user = window.auth.currentUser;
    if (!user) return;

    try {
        const userRef = window.db.ref('users/' + user.uid);
        
        // Get current data
        const snapshot = await userRef.once('value');
        const currentData = snapshot.val() || {
            email: user.email,
            username: '',
            progress: {
                questionsAnswered: 0,
                correctAnswers: 0,
                history: []
            }
        };

        // Update progress while preserving username
        const updatedProgress = {
            questionsAnswered: (currentData.progress.questionsAnswered || 0) + 1,
            correctAnswers: (currentData.progress.correctAnswers || 0) + (questionData.isCorrect ? 1 : 0),
            history: [questionData, ...(currentData.progress.history || []).slice(0, 100000)]
        };

        // Save to database
        await userRef.set({
            email: user.email,
            username: currentData.username,
            progress: updatedProgress
        });

        console.log('Database updated:', updatedProgress);
    } catch (error) {
        console.error("Error saving to database:", error);
    }
}
        </script>

    <style>
        #ttsToggle.active {
    background-color: #28a745;
    color: white;
    border-color: #28a745;
}
        .badge {
    font-size: 0.9em;
    padding: 0.5em 0.8em;
}

.bg-success {
    background-color: #28a745 !important;
}

.bg-primary {
    background-color: #007bff !important;
}

.buzz-icon {
    display: inline-block;
    background: #ffd700;
    padding: 2px 8px;
    border-radius: 4px;
    animation: buzz-flash 0.5s;
    margin-left: 5px;
}

@keyframes buzz-flash {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.me-2 {
            margin-right: 0.5rem !important;
        }

        body {
    background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%231a237e' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2V6h4V4H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
}

        .container-fluid {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 15px;
            padding: 15px;
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            color: #1a237e;
            margin-bottom: 2rem;
            font-weight: 600;
        }

        #question {
            margin: 2rem auto;
            font-size: 1.5em;
            padding: 2rem;
            border: none;
            border-radius: 12px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            line-height: 1.8;
        }

        #set-name {
            color: #555;
            font-size: 1.1em;
        }

        #set-name a {
            color: #1565c0;
            text-decoration: none;
        }

        .btn {
            border-radius: 8px;
            padding: 0.5rem 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-danger {
            background-color: #d32f2f;
        }

        .btn-primary {
            background-color: #1976d2;
        }

        .btn-secondary {
            background-color: #455a64;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #answer {
            border-radius: 8px;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
            transition: border-color 0.3s ease;
        }

        #answer:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        #speed {
            width: 200px;
            margin: 0 10px;
        }

        #setType {
            height: auto;
            min-width: 100%;
        }

        #setType option {
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        #setType option:last-child {
            border-bottom: none;
        }

        #setType:focus option:checked {
            background: linear-gradient(0deg, #1976d2 0%, #1976d2 100%);
            background-color: #1976d2 !important;
            color: white;
        }

        #result {
            font-size: 1.2em;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        #questionHistory {
            font-family: 'Inter', sans-serif;
            padding: 1rem;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-top: 2rem;
            max-height: 500px;
            overflow-y: auto;
        }

        .history-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            border-left: 4px solid transparent;
            transition: all 0.2s ease;
        }

        .history-card.correct {
            border-left-color: #28a745;
        }

        .history-card.incorrect {
            border-left-color: #dc3545;
        }

        .history-card:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .history-card .question-text {
            font-size: 0.9em;
            color: #343a40;
            margin-bottom: 8px;
        }

        .history-card .answer-section {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #666;
        }

        .history-card .correct-answer {
            color: #28a745;
            font-weight: 500;
        }

        .history-card .user-answer {
            color: #666;
        }

        .history-card .incorrect .user-answer {
            color: #dc3545;
        }

        .word {
            margin-right: 6px;
            display: inline-block;
        }

        .emphasized {
            color: #ff0000;
            font-weight: 600;
        }


        .word.hidden {
            visibility: hidden;
        }

        .hidden {
            display: none;
        }

        .navbar {
            background: #1a237e;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .navbar-brand {
            color: white !important;
            font-weight: bold;
            font-size: 1.4rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .nav-link {
            color: rgba(255,255,255,0.9) !important;
            margin: 0 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .nav-link:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-1px);
        }

        .nav-item.active .nav-link {
            background: rgba(255,255,255,0.2);
            color: white !important;
        }

        #userStats {
            background: rgba(255,255,255,0.1);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            color: white;
            margin-right: 1rem;
        }

        .auth-button {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .auth-button:hover {
            background: rgba(255,255,255,0.25);
            border-color: rgba(255,255,255,0.4);
            transform: translateY(-1px);
        }

        .dropdown-menu {
            background: #fff;
            border: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-radius: 8px;
            margin-top: 0.5rem;
        }

        .dropdown-item {
            padding: 0.75rem 1.5rem;
            transition: all 0.2s ease;
        }

        .dropdown-item:hover {
            background: #f8f9fa;
            transform: translateX(4px);
        }

        .modal-dialog.modal-lg {
            max-width: 800px;
        }

        #searchResults .card {
            transition: all 0.3s ease;
        }

        #searchResults .card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        #searchResults {
            max-height: 70vh;
            overflow-y: auto;
        }

        .modal-body {
            max-height: 80vh;
            overflow-y: auto;
        }

        .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
        }

        mark {
            background-color: #fff3cd;
            padding: 0.2em;
            border-radius: 3px;
        }

        .btn-group-toggle .btn {
            margin-right: 5px;
        }

        .btn-group-toggle .btn:last-child {
            margin-right: 0;
        }

        .btn-outline-primary:not(:disabled):not(.disabled).active {
            background-color: #1976d2;
            border-color: #1976d2;
        }

        #categoryType {
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            width: auto;
            min-width: 400px;
            background-color: white;
            font-size: 0.85em;
        }

        #categoryType:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
            outline: none;
        }

        .category-label {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        #questionHistory .mb-3 {
            background-color: #f8f9fa;
            transition: background-color 0.2s ease;
        }

        #questionHistory .mb-3:hover {
            background-color: #f0f0f0;
        }

        /* Enhanced history cards */
        .card {
            border: none;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            animation: slideIn 0.4s ease-out;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        /* Enhanced result alerts */
        .alert {
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            animation: slideIn 0.3s ease-out;
        }

        .audio-off {
            background-color: #ff4444;
            color: white;
        }

        .audio-on {
            background-color: #00C851;
            color: white;
        }

        .card.history-bowl {
            background-color: #fffff0;  /* Light yellow */
        }

        .card.history-bee {
            background-color: #f8f0ff;  /* Light violet */
        }

        /* Practice mode styles */
        .practice-modal {
            background-color: #f0f2f5;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.4s ease-out;
        }

        .practice-modal .card {
            border: none;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            animation: slideIn 0.4s ease-out;
        }

        .practice-modal .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        .practice-modal .btn {
            border-radius: 8px;
            padding: 0.5rem 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .practice-modal .btn-danger {
            background-color: #d32f2f;
        }

        .practice-modal .btn-primary {
            background-color: #1976d2;
        }

        .practice-modal .btn-secondary {
            background-color: #455a64;
        }

        .practice-modal .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .practice-modal #answer {
            border-radius: 8px;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
            transition: border-color 0.3s ease;
        }

        .practice-modal #answer:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .practice-modal #speed {
            width: 200px;
            margin: 0 10px;
        }

        .practice-modal #result {
            font-size: 1.2em;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .practice-modal .word {
            margin-right: 6px;
            display: inline-block;
        }

        .practice-modal .emphasized {
            color: #ff0000;
            font-weight: 600;
        }

        .practice-modal .word.hidden {
            visibility: hidden;
        }

        .practice-modal .hidden {
            display: none;
        }

        .practice-modal .modal-dialog.modal-lg {
            max-width: 800px;
        }

        .practice-modal #searchResults .card {
            transition: all 0.3s ease;
        }

        .practice-modal #searchResults .card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .practice-modal #searchResults {
            max-height: 70vh;
            overflow-y: auto;
        }

        .practice-modal .modal-body {
            max-height: 80vh;
            overflow-y: auto;
        }

        .practice-modal .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
        }

        .practice-modal .spinner-border {
            width: 3rem;
            height: 3rem;
        }

        .practice-modal mark {
            background-color: #fff3cd;
            padding: 0.2em;
            border-radius: 3px;
        }

        .practice-modal .btn-group-toggle .btn {
            margin-right: 5px;
        }

        .practice-modal .btn-group-toggle .btn:last-child {
            margin-right: 0;
        }

        .practice-modal .btn-outline-primary:not(:disabled):not(.disabled).active {
            background-color: #1976d2;
            border-color: #1976d2;
        }

        .practice-modal #categoryType {
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            width: auto;
            min-width: 400px;
            background-color: white;
            font-size: 0.95em;
            font-family: monospace;
        }

        .practice-modal #categoryType:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
            outline: none;
        }

        .practice-modal .category-label {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        .practice-modal #questionHistory .mb-3 {
            background-color: #f8f9fa;
            transition: background-color 0.2s ease;
        }

        .practice-modal #questionHistory .mb-3:hover {
            background-color: #f0f0f0;
        }

        .practice-modal .audio-off {
            background-color: #ff4444;
            color: white;
        }

        .practice-modal .audio-on {
            background-color: #00C851;
            color: white;
        }

        .practice-modal .card.history-bowl {
            background-color: #fffff0;  /* Light yellow */
        }

        .practice-modal .card.history-bee {
            background-color: #f8f0ff;  /* Light violet */
        }

        /* Prevent main page scrolling during practice mode */
        .modal-open {
            overflow: hidden;
        }

        .modal-backdrop.show {
            opacity: 0.5;
        }

        .modal-backdrop.fade {
            opacity: 0;
        }

        .modal-backdrop.show.fade {
            opacity: 0.5;
        }

        .modal-dialog {
            transition: transform 0.3s ease;
        }

        .modal-dialog.show {
            transform: none;
        }

        .modal-dialog.modal-lg {
            max-width: 800px;
        }

        .modal-content {
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            background-color: #f0f2f5;
            border-bottom: 1px solid #e0e0e0;
            padding: 1rem;
        }

        .modal-title {
            font-size: 1.2em;
            font-weight: 600;
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-footer {
            background-color: #f0f2f5;
            border-top: 1px solid #e0e0e0;
            padding: 1rem;
        }

        .modal-footer .btn {
            margin-left: 0.5rem;
        }

        .modal-footer .btn-primary {
            background-color: #1976d2;
            border-color: #1976d2;
        }

        .modal-footer .btn-secondary {
            background-color: #455a64;
            border-color: #455a64;
        }

        .modal-footer .btn-danger {
            background-color: #d32f2f;
            border-color: #d32f2f;
        }

        .modal-footer .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .modal-footer .btn:focus {
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .modal-footer .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .modal-footer .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .modal-footer .btn:disabled:focus {
            box-shadow: none;
        }

        .modal-footer .btn-group {
            margin-right: 0.5rem;
        }

        .modal-footer .btn-group .btn {
            margin-left: 0;
        }

        .modal-footer .btn-group .btn:first-child {
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
        }

        .modal-footer .btn-group .btn:last-child {
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .modal-footer .btn-group .btn:not(:first-child):not(:last-child) {
            border-radius: 0;
        }

        .modal-footer .btn-group .btn:not(:first-child) {
            margin-left: -1px;
        }

        .modal-footer .btn-group .btn:not(:last-child) {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .modal-footer .btn-group .btn:not(:first-child):not(:last-child) {
            border-radius: 0;
        }

        .badge-pill {
            border-radius: 10rem;
        }

        .list-group-item {
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
        }

        .navbar {
            background-color: #163779 !important; /* Azure */
        }
        
        /* Optional: adjust text color for better contrast */
        .navbar-brand, .navbar-text, .nav-link {
            color: white !important; /* Darker blue for text */
        }
        
        /* Optional: adjust button colors to match theme */
        .navbar .btn-outline-primary {
            color: #2C5282;
            border-color: #2C5282;
        }
        
        .navbar .btn-outline-primary:hover {
            background-color: #2C5282;
            color: #F0F8FF !important;
        }

        .search-tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .search-tooltip .btn-group {
            display: flex;
            gap: 4px;
        }

        .search-tooltip .btn {
            padding: 4px 8px;
            font-size: 0.9em;
        }

        .container-fluid {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 15px;
            padding: 15px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .question-container {
            grid-column: 1;
        }

        .controls-container {
            grid-column: 2;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 320px;
            margin-left: auto;
            overflow: hidden;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .control-group select,
        .control-group input {
            font-size: 0.8em;
            width: 100%;
            height: fit-content;
        }

        #question {
            font-size: 1.3em;
            margin: 1rem 0;
        }

        .btn-sm {
            font-size: 0.9em;
            padding: 0.25rem 0.5rem;
        }

        .control-group select {
            font-size: 0.8em;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 8px;
            min-height: 36px;
        }

        .control-group select option {
            font-size: 0.8em;
            white-space: normal;
            word-wrap: break-word;
            padding: 4px;
            max-width: 300px;
        }

        #categoryType {
            width: 100%;
            max-width: 100%;
            padding: 4px 8px;
        }

        #categoryType option {
            font-size: 0.8em;
            padding: 4px 6px;
            max-width: 300px;
            white-space: normal;
            word-wrap: break-word;
        }

        .search-confirm {
    position: absolute;  /* Changed from fixed */
    background: white;
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    display: none;
    z-index: 1000;
            max-width: 300px;
        }

        .search-confirm .btn {
            font-size: 0.9em;
            padding: 4px 8px;
            margin: 0 4px;
        }

        .search-confirm .selected-text {
            font-style: italic;
            color: #666;
            margin-bottom: 8px;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .history-card .metadata {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 8px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .history-card .metadata span {
            margin-right: 15px;
        }

        .history-card .set-name,
        .history-card .category {
            font-style: italic;
        }

        .history-card .set-name a {
            color: #1565c0;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .history-card .set-name a:hover {
            color: #003c8f;
            text-decoration: underline;
        }

        .frequency-analysis {
            font-size: 0.9em;
            background-color: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .frequency-analysis .card-body {
            padding: 0.8rem;
        }

        .frequency-analysis h6 {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .frequency-analysis ul {
            columns: 2;
            font-size: 0.8em;
            margin-bottom: 0;
        }

        .frequency-analysis li {
            padding: 2px 0;
            color: #555;
        }

        .search-result-card {
            font-size: 0.9em;
            margin-bottom: 0.5rem;
        }

        .search-result-card .card-body {
            padding: 0.8rem;
        }

        .search-result-card .card-subtitle {
            font-size: 0.8em;
        }

        .search-result-card .card-text {
            font-size: 0.9em;
            line-height: 1.4;
            margin-top: 0.5rem;
        }

        .search-highlight {
            background-color: #fff3cd;
            padding: 0.1em 0.2em;
            border-radius: 2px;
            margin: 0 -0.2em;
        }

        .search-result-card .card-text mark {
            background-color: #fff3cd;
        }

        .username-dropdown {
            position: relative;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 8px;
            transition: all 0.2s ease;
            border: 1px solid #ffffff;
            padding-right: 10px;
            margin-right: 10px;
        }

        .username-dropdown:hover {
            border-color: #e9ecef;
            background-color: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            
        }

        /* Add a subtle indicator */
        .username-dropdown::after {
            margin-left: 8px;
            content: '👤';
            opacity: 0.6;
        }

        .username-dropdown:hover::after {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 200px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            padding: 12px;
            border-radius: 8px;
            z-index: 1;
        }

        .username-dropdown:hover .dropdown-content {
            display: block;
        }

        .stats-item {
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .stats-item:last-child {
            border-bottom: none;
        }

        .view-missed-btn {
            width: 100%;
            margin-top: 8px;
            padding: 8px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #usernameDisplay {
            color: white;
            padding-right: 10px;
        }

        .view-missed-btn:hover {
            background-color: #0056b3;
        }

        .leaderboard-entry.gold {
            background-color: #FFD700;
            color: black;
        }
        
        .leaderboard-entry.silver {
            background-color: #C0C0C0;
            color: black;
        }
        
        .leaderboard-entry.bronze {
            background-color: #CD7F32;
            color: white;
        }

        .gold-rank {
            background-color: #FFD700 !important;
            color: black !important;
        }

        .silver-rank {
            background-color: #C0C0C0 !important;
            color: black !important;
        }

        .bronze-rank {
            background-color: #CD7F32 !important;
            color: white !important;
        }

        #startButton {
            display: block;
            margin: 20px auto;
            transition: all 0.3s ease;
        }

        #startButton:disabled {
            background-color: #ccc;
            border-color: #bbb;
            cursor: not-allowed;
        }

        .bg-light-yellow {
            background-color: #fffff0 !important;
        }
        
        .bg-light-violet {
            background-color: #f8f0ff !important;
        }
        
        .badge.bg-purple {
            background-color: #6f42c1 !important;
        }
        
        .card {
            transition: transform 0.2s ease-in-out;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .analysis-container {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .weaknesses-section {
            margin-top: 15px;
        }

        .practice-category {
            margin-left: 10px;
        }

        .bg-light-red {
            background-color: rgba(255, 0, 0, 0.1);
        }

    </style>
</head>
<body>
    <audio id="buzzSound" src="audio/buzz.mp3"></audio>
    <audio id="correctSound" src="audio/correct.mp3"></audio>
    <audio id="incorrectSound" src="audio/incorrect.mp3"></audio>

    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
            <div class="d-flex justify-content-between align-items-center w-100">
                <div class="d-flex align-items-center">
                    
                    <div class="username-dropdown">
                        <span id="usernameDisplay" style="color:white"></span>
                        <div class="dropdown-content">
                            <div class="stats-item">
                                Accuracy: <span id="accuracyStats">-</span>
                            </div>
                            <div class="stats-item">
                                Total Questions: <span id="totalQuestionsStats">-</span>
                            </div>
                            <button class="view-missed-btn" onclick="showMissedQuestions()">View Missed Questions</button>
                        </div>
                    </div>
                    <button id="authButton" class="btn btn-outline-light me-2" 
                            onclick="auth.currentUser ? handleSignOut() : $('#authModal').modal('show')">
                        Sign In
                    </button>
                    <button id="leaderboardButton" class="btn btn-outline-light me-2" onclick="showLeaderboard()">
                        Leaderboard
                    </button>
                    <button class="btn btn-outline-light" onclick="$('#searchModal').modal('show')">
                        Search Questions
                    </button>
                </div>
                
                <div id="userStats" class="text-end" style="display: none;">
                    <span class="badge bg-success me-2">Correct: <span id="correctCount">0</span></span>
                    <span class="badge bg-dark">Total Answered: <span id="totalCount">0</span></span>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="question-container">
            <div id="set-name" class="mb-3"></div>
            <div id="question"></div>
            <div class="form-group">
                <input type="text" id="answer" class="form-control mt-3" placeholder="Your answer..." disabled>
                <div id="result"></div>
                <div class="d-flex justify-content-center gap-2 mb-2">
                    <button id="buzz" class="btn btn-danger">Buzz (space)</button>
                    <button id="submit" class="btn btn-primary">Submit (enter)</button>
                    <button id="next" class="btn btn-secondary hidden">Next Question (j)</button>
                </div>
            </div>
            <div class="mt-3">
                <div id="questionHistory" class="history-container"></div>
            </div>
        </div>

        <div class="controls-container">
            <div class="control-group">
                
                <label for="speed">Reading Speed</label>
                <input type="range" id="speed" min="600" max="1000" value="800">
            </div>
            <button id="showAnalysis" class="btn btn-info" onclick="showPerformanceAnalysis()">
                📊 Performance Analysis
            </button>
            <div class="control-group">
                <label for="setType">Question Sets</label>
                <select id="setType" class="form-control" multiple size="6">
                    <option value="all">All Questions (20,050 questions)</option>
                    <option value="bowl-nationals">History Bowl Nationals (5,187 questions)</option>
                    <option value="bowl-regionals">History Bowl Regionals (8,085 questions)</option>
                    <option value="bee-nationals">History Bee Nationals (2,777 questions)</option>
                    <option value="bee-regionals">History Bee Regionals (4,001 questions)</option>
                </select>
                <small class="form-text text-muted">Hold Ctrl/Cmd to select multiple sets</small>
            </div>

            <div class="control-group">
                <label for="categoryType">Category</label>
                <select id="categoryType" class="form-control">
                    <option value="" selected disabled>Select a Category</option>
                    <option value="American History">American History (BN: 878 | BR: 1347 | BeN: 511 | BeR: 812 | Total: 3548)</option>
                    <option value="European History">European History (BN: 587 | BR: 971 | BeN: 378 | BeR: 656 | Total: 2592)</option>
                    <option value="World History">World History (BN: 402 | BR: 672 | BeN: 362 | BeR: 593 | Total: 2029)</option>
                    <option value="Ancient History">Ancient History (BN: 127 | BR: 240 | BeN: 90 | BeR: 164 | Total: 621)</option>
                    <option value="Current Events">Current Events (BN: 135 | BR: 182 | BeN: 50 | BeR: 105 | Total: 472)</option>
                    <option value="Geography">Geography (BN: 81 | BR: 185 | BeN: 59 | BeR: 135 | Total: 460)</option>
                    <option value="Trash">Trash (BN: 86 | BR: 177 | BeN: 45 | BeR: 92 | Total: 400)</option>
                    <option value="Visual Fine Arts">Visual Fine Arts (BN: 76 | BR: 138 | BeN: 37 | BeR: 86 | Total: 337)</option>
                    <option value="Auditory Fine Arts">Auditory Fine Arts (BN: 52 | BR: 122 | BeN: 32 | BeR: 72 | Total: 278)</option>
                    <option value="Other Fine Arts">Other Fine Arts (BN: 62 | BR: 88 | BeN: 29 | BeR: 45 | Total: 224)</option>
                    <option value="Philosophy">Philosophy (BN: 54 | BR: 83 | BeN: 24 | BeR: 44 | Total: 205)</option>
                    <option value="Religion">Religion (BN: 47 | BR: 81 | BeN: 18 | BeR: 48 | Total: 194)</option>
                    <option value="Social Science">Social Science (BN: 46 | BR: 80 | BeN: 17 | BeR: 49 | Total: 192)</option>
                    <option value="American Literature">American Literature (BN: 41 | BR: 60 | BeN: 22 | BeR: 44 | Total: 167)</option>
                    <option value="Mythology">Mythology (BN: 29 | BR: 71 | BeN: 19 | BeR: 37 | Total: 156)</option>
                    <option value="Other Science">Other Science (BN: 26 | BR: 60 | BeN: 9 | BeR: 33 | Total: 128)</option>
                    <option value="British Literature">British Literature (BN: 32 | BR: 42 | BeN: 20 | BeR: 25 | Total: 119)</option>
                    <option value="European Literature">European Literature (BN: 18 | BR: 36 | BeN: 10 | BeR: 19 | Total: 83)</option>
                    <option value="Physics">Physics (BN: 11 | BR: 30 | BeN: 6 | BeR: 20 | Total: 67)</option>
                    <option value="Biology">Biology (BN: 10 | BR: 32 | BeN: 7 | BeR: 8 | Total: 57)</option>
                    <option value="World Literature">World Literature (BN: 16 | BR: 22 | BeN: 9 | BeR: 8 | Total: 55)</option>
                    <option value="Chemistry">Chemistry (BN: 8 | BR: 25 | BeN: 5 | BeR: 15 | Total: 53)</option>
                </select>
            </div>

            <div class="control-group">
                <button id="audioToggle" class="btn btn-sm audio-off w-100">🔈 Audio Off</button>
            </div>
            <!--
            <div class="control-group">
                <button id="ttsToggle" class="btn btn-sm w-100">🔊 TTS Off</button>
            </div>
        -->
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        let currentQuestion = {};
        let currentIndex = 0;
        let words = [];
        let intervalId;
        let isTTSEnabled = false;
        let speechUtterance = null;
        let audioEnabled = false;
        const answerPlaceholder = document.getElementById('answer');
        answerPlaceholder.style.display = 'none';
        let allQuestions = null;
        let matches = []; // Add this at the top with other global variables

        // Add these variables at the top of your script
        let speechSynthesis = window.speechSynthesis;

        // Word frequency analyzer with blacklist
        const wordFrequencyAnalyzer = {
            // Common words to ignore by default
            blacklist: new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'at', 'to', 'for', 'with',
                'by', 'from', 'up', 'about', 'into', 'over', 'after', 'this', 'that', 'these',
                'those', 'his', 'her', 'their', 'its', 'is', 'was', 'were', 'be', 'been', 'being',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could',
                'who', 'what', 'where', 'when', 'why', 'how', 'ten points', 'points name',
                'man', 'points', 'empire', 'battle', 'war', 'of', 'ten', 'name', 'on', 'city', 'accept', 'which', 'ruler', 'one', 'point', 'as', 'first', 'led', 'he', 'capital', 'during', 'crusade', 'events', 'used', 'prompt on', 'in', 'group in', 'part of', 'of mass', 'under him', 'not prompt on', 'people', 'named', 'prompt', 'new', 'location'
            ]),

            // Words to keep even if they appear in search terms
            exceptions: new Set(['of', 'at', 'on', 'during', 'between', 'crusade']),

            // Single words that should only be blacklisted when they appear alone
            singleWordBlacklist: new Set(['empire', 'battle', 'war', 'ruled']),

            // Two-word phrases that should be blacklisted unless part of longer phrases
            twoWordBlacklist: new Set(['battle of', 'duke of', 'members of', 'member of', 'agents of', 'war of', 'empire of', 'siege of', 'site of', 'attack on', 'under him', 'series of', 'republic of', 'leader of', 'treaty of', 'defeat at', 'sack of', 'death of', 'control of', 'fall of', 'plague of', 'holder of', 'before mentioned', 'on partial', 'support of', 'not prompt', 'league of', 'part of', 'civil war', 'world war', 'king of', 'group of', 'author of', 'out of', 'body of', 'war ii', 'kingdom of', 'invasion of', 'most famous', 'son of', 'much of', 'war two', 'form of', 'assassination of', 'act of', 'political party', 'victory at', 'history of', 'island of', 'thousands of', 'holy roman', 'book of', 'council of', 'construction of', 'favor of', 'town of', 'many of', '[prompt on', 'most of', 'i of', 'put down', 'john f', 'word forms', 'raid on', 'portion of', 'two of', 'african country', 'law of', 'scientist proved', 'scientist disproved', 'father of', 'rather than', 'war between', 'fired on', 'surprise attack', 'us president', "war's battle", 'two countries']),

            // Add this after the twoWordBlacklist declaration (around line 1176)
            threeWordBlacklist: new Set([
                'battle of the', 'war of the', 'empire of the', 'siege of the', 'site of the',
                'attack on the', 'series of the', 'republic of the', 'leader of the',
                'treaty of the', 'defeat at the', 'sack of the', 'death of the',
                'control of the', 'fall of the', 'plague of the', 'holder of the',
                'league of the', 'part of the', 'king of the', 'central figure of', 'group of the',
                'author of the', 'body of the', 'kingdom of the', 'invasion of the',
                'son of the', 'form of the', 'act of the', 'victory at the',
                'history of the', 'island of the', 'council of the', 'town of the',
                'law of the', 'war between the', 'fired on the', 'attack on the', "war's battle of"
            ]),

            hasBlacklistedWords(phrase) {
                const words = phrase.split(' ');
                
                // Block phrases containing "prompt on" in that order
                for (let i = 0; i < words.length - 1; i++) {
                    if (words[i].toLowerCase() === 'prompt' && words[i + 1].toLowerCase() === 'on') {
                        return true;
                    }
                }
                
                // For single words
                if (words.length === 1) {
                    const word = words[0];
                    return (this.blacklist.has(word) || this.singleWordBlacklist.has(word)) && !this.exceptions.has(word);
                }
                
                // Block phrases that start with "of" (when it's not the only word)
                if (words.length >= 2 && words[0].toLowerCase() === 'of') {
                    return true;
                }
                
                // For two-word phrases
                if (words.length === 2) {
                    const twoWordPhrase = words.join(' ');
                    if (this.twoWordBlacklist.has(twoWordPhrase)) {
                        return true;
                    }
                }
                
                // For three-word phrases
                if (words.length === 3) {
                    const threeWordPhrase = words.join(' ');
                    if (this.threeWordBlacklist.has(threeWordPhrase)) {
                        return true;
                    }
                }
                
                // For longer phrases, only check regular blacklist words
                // (excluding words in singleWordBlacklist and twoWordBlacklist)
                return words.some(word => 
                    this.blacklist.has(word) && 
                    !this.singleWordBlacklist.has(word) && 
                    !this.exceptions.has(word)
                );
            },

            addToSingleWordBlacklist(...words) {
                words.forEach(word => {
                    this.singleWordBlacklist.add(word.toLowerCase());
                    this.blacklist.add(word.toLowerCase());
                });
            },

            removeFromSingleWordBlacklist(...words) {
                words.forEach(word => {
                    this.singleWordBlacklist.delete(word.toLowerCase());
                    this.blacklist.delete(word.toLowerCase());
                });
            },

            addToTwoWordBlacklist(...phrases) {
                phrases.forEach(phrase => {
                    this.twoWordBlacklist.add(phrase.toLowerCase());
                });
            },

            removeFromTwoWordBlacklist(...phrases) {
                phrases.forEach(phrase => {
                    this.twoWordBlacklist.delete(phrase.toLowerCase());
                });
            },

            analyzeFrequency(texts, searchTerm, maxWords = 10, minFrequency = 2) {
                const frequencies = {
                    words: new Map(),
                    phrases: new Map()
                };

                // Process search terms
                const searchTerms = searchTerm.toLowerCase().split(' ');
                const searchPhrases = new Set();
                
                // Generate all possible combinations of search terms
                for (let i = 0; i < searchTerms.length; i++) {
                    for (let j = i + 1; j <= searchTerms.length; j++) {
                        const phrase = searchTerms.slice(i, j).join(' ');
                        if (!this.exceptions.has(phrase)) {
                            searchPhrases.add(phrase);
                        }
                    }
                }

                texts.forEach(text => {
                    const cleanedText = text.toLowerCase()
                        .replace(/<[^>]+>/g, '') // Remove HTML tags
                        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '') // Remove punctuation
                        .replace(/\s{2,}/g, ' ') // Remove extra spaces
                        .trim();
                    
                    const words = cleanedText.split(' ');

                    // Single words
                    words.forEach(word => {
                        if (!this.blacklist.has(word) && 
                            word.length > 1 && 
                            (!searchPhrases.has(word) || this.exceptions.has(word))) {
                            frequencies.words.set(word, (frequencies.words.get(word) || 0) + 1);
                        }
                    });

                    // Phrases (2 to maxWords length)
                    for (let length = 2; length <= maxWords; length++) {
                        for (let i = 0; i <= words.length - length; i++) {
                            const phrase = words.slice(i, i + length).join(' ');
                            if (!this.hasBlacklistedWords(phrase) && 
                                !searchPhrases.has(phrase) && 
                                !this.containsSearchPhrase(phrase, searchPhrases)) {
                                frequencies.phrases.set(phrase, (frequencies.phrases.get(phrase) || 0) + 1);
                            }
                        }
                    }
                });

                return this.formatResults(frequencies, minFrequency);
            },

            containsSearchPhrase(phrase, searchPhrases) {
                for (const searchPhrase of searchPhrases) {
                    if (phrase.includes(searchPhrase)) {
                        return true;
                    }
                }
                return false;
            },

            formatResults(frequencies, minFrequency) {
                // First, sort by frequency and filter by minimum frequency
                const formatMap = map => {
                    return Array.from(map.entries())
                        .filter(([, count]) => count >= minFrequency)
                        .sort((a, b) => b[1] - a[1]);
                };

                const singleWords = formatMap(frequencies.words);
                const phrases = formatMap(frequencies.phrases);

                // Filter out subphrases
                const filteredPhrases = phrases.filter(([phrase1, count1]) => {
                    return !phrases.some(([phrase2, count2]) => {
                        if (phrase1 === phrase2) return false;
                        if (phrase2.includes(phrase1) && count2 >= count1) return true;
                        return false;
                    });
                });

                // Filter out single words that appear in phrases with equal or higher frequency
                const filteredWords = singleWords.filter(([word, wordCount]) => {
                    return !filteredPhrases.some(([phrase, phraseCount]) => {
                        return phrase.includes(word) && phraseCount >= wordCount;
                    });
                });

                return {
                    singleWords: filteredWords,
                    phrases: filteredPhrases
                };
            }
        };

        async function preloadQuestions() {
            const startButton = document.getElementById('startButton');
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'alert alert-info text-center';
            loadingIndicator.innerHTML = `
                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                Loading question database...
            `;
            document.querySelector('.container-fluid').prepend(loadingIndicator);

            try {
                const repositories = ['sets', 'beeSets'];
                allQuestions = [];
                
                // Fetch file lists from both local directories
                const allFiles = await Promise.all(
                    repositories.map(async repo => {
                        const response = await fetch(`/${repo}`);
                        const files = await response.json();
                        return files.map(file => ({
                            name: file,
                            download_url: `/${repo}/${file}`,
                            repo: repo
                        }));
                    })
                ).then(results => results.flat());

                // Fetch all JSON files in parallel
                const questionSets = await Promise.all(
                    allFiles.map(file => 
                        fetch(file.download_url)
                            .then(res => res.json())
                            .then(data => ({
                                data,
                                repo: file.repo,
                                name: file.name
                            }))
                            .catch(err => {
                                console.warn(`Failed to load ${file.name}:`, err);
                                return null;
                            })
                    )
                );

                // Process all successfully loaded question sets
                allQuestions = questionSets
                    .filter(set => set !== null)
                    .flatMap(({data, repo, name}) => 
                        data.tossups.map(q => ({
                            ...q,
                            setName: name.replace('.json', ''),
                            isBeeset: repo === 'beeSets'
                        }))
                    );

                loadingIndicator.remove();
                startButton.disabled = false;
                startButton.textContent = 'Start Reading Questions';
            } catch (error) {
                console.error('Error:', error);
                loadingIndicator.className = 'alert alert-danger text-center';
                loadingIndicator.textContent = 'Error loading questions. Please refresh the page.';
                startButton.textContent = 'Error Loading Questions';
            }
        }

        async function fetchQuestion() {
            try {
                const setTypeSelect = document.getElementById('setType');
                const selectedOptions = Array.from(setTypeSelect.selectedOptions).map(option => option.value);
                
                if (selectedOptions.length === 0) {
                    throw new Error('Please select at least one question set');
                }

                // Determine which repositories to fetch from based on selected options
                let repositories = new Set();
                selectedOptions.forEach(setType => {
                    if (setType === 'all' || setType.startsWith('bowl')) {
                        repositories.add('sets');
                    }
                    if (setType === 'all' || setType.startsWith('bee')) {
                        repositories.add('beeSets');
                    }
                });

                let allFiles = [];
                for (const repo of repositories) {
                    const repoUrl = `https://api.github.com/repos/charliechicken/hbNats/contents/${repo}`;
                    const filesResponse = await fetch(repoUrl);
                    const files = await filesResponse.json();
                    
                    // Filter JSON files based on selected types
                    const jsonFiles = files
                        .filter(file => file.name.endsWith('.json'))
                        .filter(file => {
                            const isNationals = file.name.toLowerCase().includes('nationals');
                            const isBee = repo === 'beeSets';
                            
                            return selectedOptions.some(setType => {
                                switch(setType) {
                                    case 'all':
                                        return true;
                                    case 'bowl-nationals':
                                        return !isBee && isNationals;
                                    case 'bowl-regionals':
                                        return !isBee && !isNationals;
                                    case 'bee-nationals':
                                        return isBee && isNationals;
                                    case 'bee-regionals':
                                        return isBee && !isNationals;
                                    default:
                                        return false;
                                }
                            });
                        });
                    
                    allFiles.push(...jsonFiles);
                }

                if (allFiles.length === 0) {
                    throw new Error('No sets found for selected question sets');
                }
                
                // Get a random file
                const randomFile = allFiles[Math.floor(Math.random() * allFiles.length)];
                const setName = randomFile.name.replace('.json', '');
                
                // Fetch the content of the selected file
                const response = await fetch(randomFile.download_url);
                const data = await response.json();
                
                // Get random question
                let tossups = data.tossups.filter(tossup => tossup.question && tossup.answer);

                // Filter by category if selected
                const categorySelect = document.getElementById('categoryType');
                const selectedCategory = categorySelect.value;

                if (selectedCategory) {
                    tossups = tossups.filter(tossup => {
                        if (!tossup.metadata) return false;
                        return tossup.metadata.toLowerCase().includes(selectedCategory.toLowerCase());
                    });
                    
                    if (tossups.length === 0) {
                        return fetchQuestion();
                    }
                }

                const randomQuestion = tossups[Math.floor(Math.random() * tossups.length)];
                
                currentQuestion = {
                    question: randomQuestion.question,
                    answer: randomQuestion.answer,
                    setName: setName,
                    metadata: randomQuestion.metadata,
                    pdfLink: `https://www.iacompetitions.com/wp-content/uploads/sites/5/2023/08/${setName}.pdf`
                };
                
                const cleanQuestion = currentQuestion.question.replace(/<[^>]+>/g, '');
                words = cleanQuestion.split(/\s+/);
                
                currentIndex = 0;
                document.getElementById('result').innerText = '';
                
                const questionDiv = document.getElementById('question');
                questionDiv.innerHTML = words.map((word, index) => {
                    return `<span class="word hidden">${word}</span>`;
                }).join(' ');
                
                document.getElementById('set-name').innerHTML = `Set: ${currentQuestion.setName} <a href="${currentQuestion.pdfLink}" target="_blank">PDF</a>`;
                startDisplayingWords();
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = `
                    <div class="alert alert-danger">
                        ${error.message}
                    </div>`;
            }
        }

        function startDisplayingWords() {
            const sliderValue = document.getElementById('speed').value;
            const speed = 1100 - sliderValue;
            
            // Start TTS for full question
            if (isTTSEnabled) {
                const cleanQuestion = currentQuestion.question.replace(/<[^>]+>/g, '');
                readQuestionWithTTS(cleanQuestion);
            }
            
            intervalId = setInterval(displayNextWord, speed);
        }

        function displayNextWord() {
            if (currentIndex < words.length) {
                const wordElements = document.querySelectorAll('#question .word');
                wordElements[currentIndex].classList.remove('hidden');
                currentIndex++;
                // Remove next button if it's visible during reading
                document.getElementById('next').classList.add('hidden');
            } else {
                clearInterval(intervalId);
                document.getElementById('next').classList.remove('hidden');
            }
        }

        function disableSubmit() {
            document.getElementById('submit').classList.add('hidden');
            document.getElementById('answer').disabled = true;
        }

        function enableSubmit() {
            document.getElementById('submit').classList.remove('hidden');
            document.getElementById('answer').disabled = false;
        }

        // Update the submit event listener
        document.getElementById('submit').addEventListener('click', async () => {
            if (isSubmitting) return;
            isSubmitting = true;
            
            const userAnswer = document.getElementById('answer').value.toLowerCase().trim();
            const correctAnswer = currentQuestion.answer;

            // Show all remaining words
            const wordElements = document.querySelectorAll('#question .word');
            wordElements.forEach(element => element.classList.remove('hidden'));

            const result = checkAnswer(userAnswer, correctAnswer);

            if (result.needsPrompt && !hasBeenPrompted) {
                hasBeenPrompted = true;
                document.getElementById('result').innerHTML = `
                    <div class="alert alert-warning">
                        Please be more specific.
                    </div>`;
                document.getElementById('answer').value = '';
                document.getElementById('answer').focus();
                isSubmitting = false;
                return;
            }

            // Reset prompt flag for next question
            hasBeenPrompted = false;

            // Add to question history using the existing function
            addToQuestionHistory(currentQuestion, userAnswer, result.isCorrect);

            if (result.isCorrect) {
                if (audioEnabled) {
                    document.getElementById('correctSound').play();
                }
                document.getElementById('result').innerHTML = `
                    <div class="alert alert-success">
                        Correct! The answer was: ${correctAnswer.replace(/<b>(.*?)<\/b>/g, '<span class="emphasized">$1</span>')}
                    </div>`;
            } else {
                if (audioEnabled) {
                    document.getElementById('incorrectSound').play();
                }
                document.getElementById('result').innerHTML = `
                    <div class="alert alert-danger">
                        Incorrect. The answer was: ${correctAnswer.replace(/<b>(.*?)<\/b>/g, '<span class="emphasized">$1</span>')}
                    </div>`;
            }
            
            document.getElementById('answer').style.display = 'none';
            document.getElementById('next').classList.remove('hidden');
            disableSubmit();
            
            setTimeout(() => {
                isSubmitting = false;
            }, 500);
        });

        // Add 'j' key listener for next question
        document.addEventListener('keydown', (event) => {
            const answerInput = document.getElementById('answer');
            if (event.key === 'j' && 
                !document.getElementById('next').classList.contains('hidden') && 
                !answerInput.matches(':focus')) {
                document.getElementById('next').click();
            }
        });

        // Update next question event listener
        document.getElementById('next').addEventListener('click', () => {
            document.getElementById('question').innerHTML = '';
            document.getElementById('answer').value = '';
            document.getElementById('next').classList.add('hidden');
            enableSubmit();
            fetchQuestion();
        });

        document.getElementById('answer').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('submit').click();
            }
        });

        document.getElementById('speed').addEventListener('input', (event) => {
            if (intervalId) {
                clearInterval(intervalId);
                const sliderValue = event.target.value;
                const speed = 1100 - sliderValue;
                intervalId = setInterval(displayNextWord, speed);
            }
        });

        // Handle buzz button and spacebar
        function handleBuzz() {
            if (intervalId) {
                clearInterval(intervalId);
                // Cancel TTS when buzzing
                if (speechUtterance) {
                    window.speechSynthesis.cancel();
                }
                const answerInput = document.getElementById('answer');
                answerInput.disabled = false;
                answerInput.style.display = 'block';
                answerInput.focus();
                document.getElementById('buzz').disabled = true;
                document.getElementById('submit').classList.remove('hidden');
                
                if (audioEnabled) {
                    document.getElementById('buzzSound').play();
                }
            }
        }

        document.getElementById('buzz').addEventListener('click', handleBuzz);

        // Add spacebar listener for buzz
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && !event.repeat && 
                !document.getElementById('answer').matches(':focus') && 
                !document.getElementById('searchModal').classList.contains('show')) {
                event.preventDefault();
                handleBuzz();
            }
        });

        // Reset buzz button on next question
        document.getElementById('next').addEventListener('click', () => {
            document.getElementById('buzz').disabled = false;
            document.getElementById('answer').disabled = true;
        });

        // Fetch a question when the page loads
        fetchQuestion();

        document.getElementById('audioToggle').addEventListener('click', () => {
            audioEnabled = !audioEnabled;
            const button = document.getElementById('audioToggle');
            if (audioEnabled) {
                button.innerHTML = '🔊 Audio On';
                button.classList.remove('audio-off');
                button.classList.add('audio-on');
            } else {
                button.innerHTML = '🔈 Audio Off';
                button.classList.remove('audio-on');
                button.classList.add('audio-off');
            }
        });

        let currentQuestions = [];

        async function searchQuestions() {
            const searchInput = document.getElementById('searchInput').value;
            const searchType = document.querySelector('input[name="searchType"]:checked').value;
            const includeQbreader = document.getElementById('includeQbreader').checked;
            
            if (!searchInput.trim()) return;
            
            // Show loading state and modals
            document.getElementById('searchResults').innerHTML = `
                <div class="loading-spinner">
                    <div class="spinner-border text-primary"></div>
                    <div>Searching questions...</div>
                </div>`;
            
            $('#searchModal').modal('hide');
            $('#resultsModal').modal('show');
            
            try {
                // Split search terms and clean them
                const searchTerms = searchInput.split(',').map(term => term.trim()).filter(term => term.length > 0);
                
                // Only get QB Reader results if checkbox is checked
                const qbReaderResults = includeQbreader ? await searchQBReader(searchInput, searchType) : [];
                
                // Get local results for all terms
                const localResults = allQuestions.filter(q => {
                    const questionText = (q.question || '').toLowerCase();
                    const answerText = (q.answer || '').toLowerCase().replace(/<[^>]+>/g, '');
                    
                    return searchTerms.some(term => {
                        const searchLower = term.toLowerCase();
                        if (searchType === 'question') {
                            return questionText.includes(searchLower);
                        } else if (searchType === 'answer') {
                            return answerText.includes(searchLower);
                        }
                        return questionText.includes(searchLower) || answerText.includes(searchLower);
                    });
                });

                // Combine results
                currentQuestions = [...localResults, ...qbReaderResults];
                
                // Display results with existing code
                const resultsContainer = document.getElementById('searchResults');
                resultsContainer.innerHTML = currentQuestions.map((q, index) => {
                    let cardClass = 'bg-white';
                    let sourceType = '';
                    let badgeClass = '';
                    
                    if (q.isQBReader) {
                        cardClass = 'bg-light';
                        sourceType = 'QB Reader';
                        badgeClass = 'bg-info';
                    } else if (q.setName.toLowerCase().includes('bee')) {
                        cardClass = 'bg-light-violet';
                        sourceType = 'History Bee';
                        badgeClass = 'bg-purple';
                    } else {
                        cardClass = 'bg-light-yellow';
                        sourceType = 'History Bowl';
                        badgeClass = 'bg-warning';
                    }

                    // Highlight all search terms in the question and answer
                    let highlightedQuestion = q.question;
                    let highlightedAnswer = q.answer;
                    searchTerms.forEach(term => {
                        const regex = new RegExp(term.trim(), 'gi');
                        highlightedQuestion = highlightedQuestion.replace(regex, match => `<mark>${match}</mark>`);
                        highlightedAnswer = highlightedAnswer.replace(regex, match => `<mark>${match}</mark>`);
                    });

                    return `
                        <div class="card mb-3 ${cardClass}">
                            <div class="card-body">
                                <div class="form-check">
                                    <input type="checkbox" class="form-check-input" id="question${index}">
                                    <label class="form-check-label" for="question${index}">
                                        <h6 class="card-subtitle mb-2 text-muted">
                                            ${q.setName} 
                                            <span class="badge ${badgeClass} ms-2">${sourceType}</span>
                                        </h6>
                                        <p class="card-text">${highlightedQuestion}</p>
                                        <p class="card-text"><small class="text-muted">Answer: ${highlightedAnswer}</small></p>
                                    </label>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                updateSelectedCount();
                
            } catch (error) {
                console.error('Search error:', error);
                document.getElementById('searchResults').innerHTML = `
                    <div class="alert alert-danger">
                        Error searching questions. Please try again.
                    </div>`;
            }
        }

        function updateSelectedCount() {
            const checkedBoxes = document.querySelectorAll('#searchResults input[type="checkbox"]:checked');
            const count = checkedBoxes.length;
            document.getElementById('selectedCount').textContent = `${count} question${count !== 1 ? 's' : ''} selected`;
            
            // Update selectedQuestions array
            selectedQuestions = Array.from(checkedBoxes).map(checkbox => {
                const index = checkbox.id.replace('question', '');
                return currentQuestions[parseInt(index)];
            });
        }

        // Add debounce function at the top
        let isSubmitting = false;

        async function handleSubmit() {
            if (isSubmitting) return; // Prevent double submission
            isSubmitting = true;
            
            console.log('handleSubmit called');
            const userAnswer = document.getElementById('answer').value.trim();
            const isCorrect = checkAnswer(userAnswer, currentQuestion.answer);
            
            // Add to history without saving progress (checkAnswer handles that)
            addToQuestionHistory(currentQuestion, userAnswer, isCorrect);
            
            // Show next button
            document.getElementById('next').style.display = 'block';
            
            // Reset submission lock after a short delay
            setTimeout(() => {
                isSubmitting = false;
            }, 1000);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const startButton = document.createElement('button');
            startButton.id = 'startButton';
            startButton.className = 'btn btn-primary btn-lg mb-4';
            startButton.textContent = 'Loading Questions...';
            startButton.disabled = true;
            
            // Insert start button at the top of the question container
            const questionContainer = document.querySelector('.question-container');
            questionContainer.insertBefore(startButton, questionContainer.firstChild);

            await preloadQuestions();
            
            // Pre-select 'all' option and trigger change event
            const setTypeSelect = document.getElementById('setType');
            const allOption = Array.from(setTypeSelect.options).find(option => option.value === 'all');
            if (allOption) {
                allOption.selected = true;
                setTypeSelect.dispatchEvent(new Event('change'));
            }

            // Enable start button after questions are loaded
            startButton.disabled = false;
            startButton.textContent = 'Start Reading Questions';

            // Add start button click handler
            startButton.addEventListener('click', () => {
                startButton.style.display = 'none';  // Hide the button
                document.getElementById('buzz').disabled = false; // Enable buzz button
                document.getElementById('answer').style.display = 'none'; // Hide answer input
                document.getElementById('submit').classList.add('hidden'); // Hide submit button
                fetchQuestion();
            });
            
            // Add search input listener
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    searchQuestions();
                }
            });
            
            // Add submit button listener
            const submitButton = document.getElementById('submit');
            submitButton.addEventListener('click', (e) => {
                e.preventDefault();
                handleSubmit();
            });
            
            // Add enter key listener for answer input
            const answerInput = document.getElementById('answer');
            answerInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    handleSubmit();
                }
            });
        });

        function highlightSearchTerms(text, searchTerm) {
            if (!searchTerm) return text;
            const searchTerms = searchTerm.toLowerCase().split(' ').filter(term => term.length > 0);
            
            // Replace HTML tags with placeholders to preserve them
            const placeholders = [];
            const textWithoutTags = text.replace(/<[^>]+>/g, match => {
                placeholders.push(match);
                return `__TAG${placeholders.length - 1}__`;
            });
            
            // Highlight search terms
            let highlightedText = textWithoutTags;
            searchTerms.forEach(term => {
                const regex = new RegExp(term, 'gi');
                highlightedText = highlightedText.replace(regex, match => 
                    `<mark class="search-highlight">${match}</mark>`
                );
            });
            
            // Restore HTML tags
            placeholders.forEach((tag, index) => {
                highlightedText = highlightedText.replace(`__TAG${index}__`, tag);
            });
            
            return highlightedText;
        }

        function showResult(isCorrect, correctAnswer) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `
                <div class="alert ${isCorrect ? 'alert-success' : 'alert-danger'}">
                    <strong>${isCorrect ? 'Correct!' : 'Incorrect.'}</strong><br>
                    Answer: ${correctAnswer}<br>
                    Category: ${currentQuestion.metadata || 'Uncategorized'}<br>
                    Set: ${currentQuestion.setName}
                </div>`;
        }

        function addToQuestionHistory(question, userAnswer, isCorrect) {
            const historyDiv = document.getElementById('questionHistory');
            
            // Show history div if it's the first answer
            if (historyDiv.style.display === 'none') {
                historyDiv.style.display = 'block';
            }
            
            const card = document.createElement('div');
            card.className = `history-card ${isCorrect ? 'correct' : 'incorrect'}`;
            
            // Extract question text properly
            const questionText = typeof question === 'string' ? question : 
                                (question.question || 'Question not available');
            
            // Create PDF link for set name
            const setPdfLink = currentQuestion.setName ? 
                `<a href="https://www.iacompetitions.com/wp-content/uploads/sites/5/2023/08/${currentQuestion.setName}.pdf" 
                    target="_blank" rel="noopener noreferrer">${currentQuestion.setName}</a>` : 
                'Unknown';
            
            card.innerHTML = `
                <div class="question-text">${questionText}</div>
                <div class="answer-section">
                    <div class="metadata">
                        <span class="set-name">Set: ${setPdfLink}</span>
                        <span class="category">Category: ${currentQuestion.metadata || 'Uncategorized'}</span>
                    </div>
                    <div>
                        <span class="user-answer">Your answer: ${userAnswer}</span>
                    </div>
                    <div>
                        <span class="correct-answer">Correct answer: ${currentQuestion.answer.replace(/<\/?[^>]+(>|$)/g, '')}</span>
                    </div>
                </div>
            `;
            
            // Add to beginning of history
            if (historyDiv.firstChild) {
                historyDiv.insertBefore(card, historyDiv.firstChild);
            } else {
                historyDiv.appendChild(card);
            }
            
            // Keep only last 10 questions
            while (historyDiv.children.length > 10) {
                historyDiv.removeChild(historyDiv.lastChild);
            }
        }

        async function handleSignUp() {
    const email = document.getElementById('authEmail').value;
    const password = document.getElementById('authPassword').value;
    const username = document.getElementById('authUsername').value;
    
    if (!username.trim()) {
        alert('Username is required');
        return;
    }
    
    try {
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        const user = userCredential.user;
        
        // Save user data including username
        await window.db.ref("users/" + user.uid).set({
            email: user.email,
            username: username,
            progress: {
                questionsAnswered: 0,
                correctAnswers: 0,
                history: []
            }
        });
        
        $('#authModal').modal('hide');
    } catch (error) {
        alert(`Error: ${error.message}`);
    }
}

        async function handleSignIn() {
            const email = document.getElementById('authEmail').value;
            const password = document.getElementById('authPassword').value;
            
            try {
                await auth.signInWithEmailAndPassword(email, password);
                $('#authModal').modal('hide');
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        async function handleSignOut() {
            try {
                await window.auth.signOut();
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }



        function normalizeAnswer(answer) {
            if (!answer) return [];
            
            // Convert to lowercase and remove extra spaces
            answer = answer.toLowerCase().trim();
            
            // Extract bold/underlined text (text between various tags)
            const tagMatches = answer.match(/<[bu]>(.*?)<\/[bu]>|_(.*?)_/g);
            
            if (tagMatches) {
                // Get the emphasized text
                const emphasizedAnswers = tagMatches.map(match => 
                    match.replace(/<[^>]+>|_/g, '').trim()
                );
                
                // Remove all HTML tags for the full answer
                const fullAnswer = answer.replace(/<[^>]+>/g, '').trim()
                    .replace(/[^a-z0-9\s]/g, '')
                    .replace(/\s+/g, ' ');
                    
                // Return both the emphasized parts and the full answer
                return [...new Set([...emphasizedAnswers, fullAnswer])];
            }
            
            // If no tags, just clean and return the full answer
            return [answer.replace(/<[^>]+>/g, '') // Remove all HTML tags
                     .replace(/[^a-z0-9\s]/g, '') // Remove special characters
                     .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                     .trim()];
        }

        function checkAnswer(userAnswer, correctAnswer) {
            console.log('checkAnswer called with:', { userAnswer, correctAnswer });
            
            // If no answer given, count as incorrect
            if (!userAnswer.trim()) {
                if (window.auth?.currentUser) {
                    const questionData = {
                        question: currentQuestion.question,
                        answer: correctAnswer,
                        userAnswer: '',
                        isCorrect: false,
                        timestamp: new Date().toISOString(),
                        setName: currentQuestion.setName || ''
                    };
                    saveUserProgress(questionData);
                }
                showResult(false, correctAnswer);
                return { isCorrect: false, needsPrompt: false };
            }
            
            // Normalize both answers
            const normalizedUserAnswer = normalizeAnswer(userAnswer)[0]; // Take first normalized answer
            const acceptedAnswers = normalizeAnswer(correctAnswer);
            
            console.log('Normalized user answer:', normalizedUserAnswer);
            console.log('Accepted answers:', acceptedAnswers);
            
            // Check if user's answer contains any of the accepted answers
            const isCorrect = acceptedAnswers.some(accepted => {
                const cleanAccepted = accepted.toLowerCase().trim();
                return normalizedUserAnswer.includes(cleanAccepted) || 
                       cleanAccepted.includes(normalizedUserAnswer);
            });
            
            console.log('Answer is:', isCorrect ? 'correct' : 'incorrect');
            
            if (window.auth?.currentUser) {
                const questionData = {
                    question: currentQuestion.question,
                    answer: correctAnswer,
                    userAnswer: userAnswer,
                    isCorrect: isCorrect,
                    timestamp: new Date().toISOString(),
                    setName: currentQuestion.setName || ''
                };
                saveUserProgress(questionData);
            }
            
            showResult(isCorrect, correctAnswer);
            return { isCorrect, needsPrompt: false };
        }

        async function showLeaderboard() {
    const leaderboardList = document.getElementById('leaderboardList');
    leaderboardList.innerHTML = '<div class="text-center">Loading...</div>';
    
    try {
        const usersRef = window.db.ref('users');
        const snapshot = await usersRef.orderByChild('progress/correctAnswers')
            .limitToLast(100)
            .once('value');
        
        const users = [];
        snapshot.forEach(childSnapshot => {
            const userData = childSnapshot.val();
            if (userData.username && userData.progress) {
                users.push({
                    username: userData.username,
                    correctAnswers: userData.progress.correctAnswers || 0
                });
            }
        });
        
        // Sort in descending order
        users.sort((a, b) => b.correctAnswers - a.correctAnswers);
        
        // Update the modal content
        leaderboardList.innerHTML = users.map((user, index) => `
            <div class="list-group-item d-flex justify-content-between align-items-center ${
                index === 0 ? 'gold-rank' : 
                index === 1 ? 'silver-rank' : 
                index === 2 ? 'bronze-rank' : ''
            }">
                <span>${index + 1}. ${user.username}</span>
                <span class="badge bg-primary rounded-pill">${user.correctAnswers}</span>
            </div>
        `).join('');
        $('#leaderboardModal').modal('show');

    } catch (error) {
        console.error('Error:', error);
        leaderboardList.innerHTML = '<div class="alert alert-danger">Error loading leaderboard</div>';
            }
        }

        document.addEventListener('mouseup', function(e) {
            const selectedText = window.getSelection().toString().trim();
            const searchConfirm = document.getElementById('searchConfirm');
            const isInModal = e.target.closest('.modal') !== null;
            
            // Only proceed if we have selected text
            if (selectedText && selectedText.length > 0) {
                // For modal selections, auto-search if word length > 2
                if (isInModal && selectedText.length > 3) {
                    document.getElementById('searchInput').value = selectedText;
                    searchQuestions();
                    window.getSelection().removeAllRanges();
                    return;
                }
                
                // For main page selections, show confirmation dialog
                if (!isInModal) {
                    if (!searchConfirm) {
                        // Create confirm dialog if it doesn't exist
                        const confirm = document.createElement('div');
                        confirm.id = 'searchConfirm';
                        confirm.className = 'search-confirm';
                        confirm.innerHTML = `
                            <div class="selected-text"></div>
                            <button class="btn btn-primary btn-sm search-yes">Search</button>
                            <button class="btn btn-secondary btn-sm search-no">Cancel</button>
                        `;
                        document.body.appendChild(confirm);
                    }
                    
                    const confirm = document.getElementById('searchConfirm');
                    confirm.querySelector('.selected-text').textContent = `Search for: "${selectedText}"`;
                    
                    // Position the confirm dialog near the mouse
                    confirm.style.left = `${e.pageX}px`;
                    confirm.style.top = `${e.pageY + 20}px`;
                    confirm.style.display = 'block';
                    
                    // Handle search confirmation
                    confirm.querySelector('.search-yes').onclick = function() {
                        document.getElementById('searchInput').value = selectedText;
                        searchQuestions();
                        confirm.style.display = 'none';
                    };
                    
                    // Handle cancellation
                    confirm.querySelector('.search-no').onclick = function() {
                        confirm.style.display = 'none';
                    };
                    
                    // Close if clicked outside
                    document.addEventListener('mousedown', function closeConfirm(e) {
                        if (!confirm.contains(e.target)) {
                            confirm.style.display = 'none';
                            document.removeEventListener('mousedown', closeConfirm);
                        }
                    });
                }
            }
        });

        let selectedQuestions = [];

function updateSelectedCount() {
    const checkedBoxes = document.querySelectorAll('#searchResults input[type="checkbox"]:checked');
    const count = checkedBoxes.length;
    document.getElementById('selectedCount').textContent = `${count} question${count !== 1 ? 's' : ''} selected`;
    
    // Update selectedQuestions array
    selectedQuestions = Array.from(checkedBoxes).map(checkbox => {
        const index = checkbox.id.replace('question', '');
        return currentQuestions[parseInt(index)];
    });
}

        function initializeSelectedQuestions(matches) {
            selectedQuestions = [...matches];
            updateSelectedCount();
        }


        function toggleAllQuestions() {
            const checkboxes = document.querySelectorAll('#searchResults input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(cb => {
                cb.checked = !allChecked;
            });
            
            updateSelectedCount();
        }

        function practiceSelectedQuestions() {
            if (selectedQuestions.length === 0) {
                alert('Please select at least one question to practice');
                return;
            }
            
            // Initialize practice state
            practiceState = {
                questions: selectedQuestions,
                currentIndex: 0,
                unseenQuestions: [...Array(selectedQuestions.length).keys()],
                words: [],
                wordIndex: 0,
                interval: null,
                isBuzzed: false,
                speed: document.getElementById('speed')?.value || 500
            };
            
            // Hide results modal and show practice modal
            $('#resultsModal').modal('hide');
            $('#practiceModal').modal('show');
            
            // Start with first question
            showPracticeQuestion(selectedQuestions[0]);
        }

        let practiceQuestionIndex = 0;

        function initializePracticeSession() {
            const practiceQuestions = JSON.parse(localStorage.getItem('practiceQuestions'));
            if (!practiceQuestions || practiceQuestions.length === 0) return;
            
            practiceQuestionIndex = 0;
            displayPracticeQuestion(practiceQuestions[practiceQuestionIndex]);
        }

        let practiceWordIndex = 0;
        let practiceWordInterval;
        let practiceWords = [];
        let isPracticeBuzzed = false;

        function displayPracticeQuestion(question) {
            practiceState.words = question.question.split(/\s+/);
            practiceState.wordIndex = 0;
            practiceState.isBuzzed = false;
            
            const practiceDiv = document.createElement('div');
            practiceDiv.innerHTML = `
                <div class="card mb-3">
                    <div class="card-body">
                        <h6 class="card-subtitle mb-2 text-muted">
                            Set: ${question.setName} 
                            (${question.isBeeset ? 'History Bee' : 'History Bowl'})
                        </h6>
                        <div class="mb-3">
                            <label for="practiceSpeed" class="form-label">Reading Speed</label>
                            <input type="range" class="form-range" id="practiceSpeed" 
                                min="100" max="1000" value="${practiceState.speed}">
                        </div>
                        <div id="practiceQuestionDisplay" class="card-text"></div>
                        <div class="mt-3">
                            <input type="text" class="form-control" id="practiceAnswerInput" 
                                placeholder="Your answer..." disabled>
                            <div class="d-flex gap-2 mt-2">
                                <button class="btn btn-danger" id="practiceBuzzBtn">Buzz (space)</button>
                                <button class="btn btn-primary" id="practiceSubmitBtn" disabled>Submit (enter)</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('practiceModalBody').innerHTML = '';
            document.getElementById('practiceModalBody').appendChild(practiceDiv);
            
            setupPracticeListeners();
            startPracticeWords();
        }

        function startPracticeWords() {
            const display = document.getElementById('practiceQuestionDisplay');
            const speedSlider = document.getElementById('practiceSpeed');
            
            clearInterval(practiceState.interval);
            
            // Only clear display and reset index if this is a new question
            if (practiceState.wordIndex === 0) {
                display.innerHTML = '';
            }
            
            // If changing speed mid-question, keep existing words displayed
            if (practiceState.wordIndex > 0) {
                display.innerHTML = practiceState.words.slice(0, practiceState.wordIndex).join(' ') + ' ';
            }
            
            practiceState.interval = setInterval(() => {
                if (practiceState.wordIndex < practiceState.words.length && !practiceState.isBuzzed) {
                    display.innerHTML += practiceState.words[practiceState.wordIndex] + ' ';
                    practiceState.wordIndex++;
                } else if (practiceState.wordIndex >= practiceState.words.length) {
                    clearInterval(practiceState.interval);
                }
            }, 1100 - parseInt(speedSlider.value));
        }

        function checkPracticeAnswer() {
            const practiceQuestions = JSON.parse(localStorage.getItem('practiceQuestions'));
            const currentQuestion = practiceQuestions[practiceQuestionIndex];
            const userAnswer = document.getElementById('practiceAnswer').value.toLowerCase().trim();
            const correctAnswer = currentQuestion.answer.replace(/<[^>]+>/g, '').toLowerCase();
            const speedSlider = document.getElementById('practiceSpeed');
            const currentSpeed = speedSlider.value;
            
            // Show full question with HTML tags
            document.getElementById('practiceQuestionDisplay').innerHTML = currentQuestion.question;
            

            
            document.getElementById('practiceModalBody').appendChild(resultDiv);
            
            // Restore speed slider value
            document.getElementById('practiceSpeed').value = currentSpeed;
        }

        function handlePracticeBuzz() {
    if (practiceState.isBuzzed) return;
    
    practiceState.isBuzzed = true;
    clearInterval(practiceState.interval);
    
    const answerInput = document.getElementById('practiceAnswerInput');
    const submitBtn = document.getElementById('practiceSubmitBtn');
    
    // Add buzz indicator
    const questionDisplay = document.getElementById('practiceQuestionDisplay');
    const buzzSpan = document.createElement('span');
    buzzSpan.className = 'buzz-icon';
    buzzSpan.textContent = '🔔';
    questionDisplay.appendChild(buzzSpan);
    
    answerInput.disabled = false;
    submitBtn.disabled = false;
            answerInput.focus();
        }

        // Prevent space from triggering button clicks when typing
        document.addEventListener('keydown', (e) => {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.tagName === 'INPUT' && e.code === 'Space') {
                e.stopPropagation(); // Prevent space from triggering buzz when typing
            }
        });

        function displaySearchResults(matches) {
            const searchResults = document.getElementById('searchResults');
            
            if (matches.length === 0) {
                searchResults.innerHTML = '<div class="alert alert-info">No matches found.</div>';
                return;
            }

            // Frequency analysis section
            const texts = matches.map(q => q.question);
            const searchTerm = document.getElementById('searchInput').value;
            const frequencyResults = wordFrequencyAnalyzer.analyzeFrequency(texts, searchTerm);

            const frequencyHtml = `
                <div class="card frequency-analysis">
                    <div class="card-body">
                        <div class="row g-2">
                            <div class="col-md-6">
                                <h6>Common Words</h6>
                                <ul class="list-unstyled">
                                    ${frequencyResults.singleWords.slice(0, 10).map(([word, count]) => 
                                        `<li><small>${word} <span class="text-muted">(${count})</span></small></li>`
                                    ).join('')}
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <h6>Common Phrases</h6>
                                <ul class="list-unstyled">
                                    ${frequencyResults.phrases.slice(0, 100).map(([phrase, count]) => 
                                        `<li><small>${phrase} <span class="text-muted">(${count})</span></small></li>`
                                    ).join('')}
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Search results section
            const resultsHtml = matches.map((q, index) => `
                <div class="card search-result-card ${q.isBeeset ? 'history-bee' : 'history-bowl'}">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="form-check">
                                <input class="form-check-input question-selector" 
                                    type="checkbox" 
                                    value="${index}" 
                                    id="check-${index}" 
                                    checked>
                                <label class="form-check-label" for="check-${index}">
                                    <small>Select for practice</small>
                                </label>
                            </div>
                            <small class="text-muted">
                                Set: ${q.setName} 
                                (${q.isBeeset ? 'History Bee' : 'History Bowl'})
                            </small>
                        </div>
                        <div class="card-text">
                            ${highlightSearchTerms(q.question, searchTerm)}
                        </div>
                        <div class="card-text mt-2 text-muted">
                            <p>Answer: ${highlightSearchTerms(q.answer, searchTerm)}</p>
                        </div>
                    </div>
                </div>
            `).join('');

            searchResults.innerHTML = frequencyHtml + resultsHtml;
        }

        let practiceState = {
            questions: [],
            currentIndex: 0,
            unseenQuestions: [],
            words: [],
            wordIndex: 0,
            interval: null,
            isBuzzed: false,
            speed: 500 // Add this to track speed across questions
        };

        function initializePracticeQuestions() {
            practiceState.questions = JSON.parse(localStorage.getItem('practiceQuestions'));
            if (!practiceState.questions || practiceState.questions.length === 0) return;
            
            // Initialize unseen questions with all indices
            practiceState.unseenQuestions = [...Array(practiceState.questions.length).keys()];
            
            // Get first random question
            if (practiceState.unseenQuestions.length > 0) {
                const randomIndex = Math.floor(Math.random() * practiceState.unseenQuestions.length);
                practiceState.currentIndex = practiceState.unseenQuestions[randomIndex];
                practiceState.unseenQuestions.splice(randomIndex, 1);
                
                // Show first question
                showPracticeQuestion(practiceState.questions[practiceState.currentIndex]);
            } else {
                console.error('No practice questions available');
            }
        }

        function showPracticeQuestion(question) {
            if (!question) {
                console.error('Invalid question provided');
                return;
            }

            practiceState.words = question.question.split(/\s+/);
            practiceState.wordIndex = 0;
            practiceState.isBuzzed = false;
            
            const questionsRemaining = practiceState.unseenQuestions.length;
            const totalQuestions = practiceState.questions.length;
            
            const practiceDiv = document.createElement('div');
            practiceDiv.innerHTML = `
                <div class="card mb-3">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="card-subtitle mb-0 text-muted">
                                Set: ${question.setName} 
                                (${question.isBeeset ? 'History Bee' : 'History Bowl'})
                            </h6>
                            <span class="badge bg-primary">
                                ${questionsRemaining} question${questionsRemaining !== 1 ? 's' : ''} remaining
                            </span>
                        </div>
                        <div class="mb-3">
                            <label for="practiceSpeed" class="form-label">Reading Speed</label>
                            <input type="range" class="form-range" id="practiceSpeed" 
                                min="100" max="1000" value="${practiceState.speed}">
                        </div>
                        <div id="practiceQuestionDisplay" class="card-text"></div>
                        <div class="mt-3">
                            <input type="text" class="form-control" id="practiceAnswerInput" 
                                placeholder="Your answer..." disabled>
                            <div class="d-flex gap-2 mt-2">
                                <button class="btn btn-danger" id="practiceBuzzBtn">Buzz (space)</button>
                                <button class="btn btn-primary" id="practiceSubmitBtn" disabled>Submit (enter)</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('practiceModalBody').innerHTML = '';
            document.getElementById('practiceModalBody').appendChild(practiceDiv);
            
            setupPracticeListeners();
            startPracticeWords();
        }

        function setupPracticeListeners() {
            document.getElementById('practiceBuzzBtn').onclick = handlePracticeBuzz;
            document.getElementById('practiceSubmitBtn').onclick = submitPracticeAnswer;
            
            const speedSlider = document.getElementById('practiceSpeed');
            speedSlider.addEventListener('input', (e) => {
                practiceState.speed = parseInt(e.target.value); // Save speed to state
                clearInterval(practiceState.interval);
                startPracticeWords(); // This will now continue from current position
            });
            
            document.addEventListener('keydown', handlePracticeKeypress);
        }

        function handlePracticeKeypress(e) {
            if (!document.getElementById('practiceModal').classList.contains('show')) return;
            
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                if (!practiceState.isBuzzed) handlePracticeBuzz();
            } else if (e.code === 'Enter' && !e.repeat) {
                if (practiceState.isBuzzed) submitPracticeAnswer();
            } else if (e.code === 'KeyJ' && !e.repeat) {
                const nextBtn = document.querySelector('[onclick="goToNextPractice()"]');
                if (nextBtn) goToNextPractice();
            }
        }

        function submitPracticeAnswer() {
            // Add submission lock
            if (practiceState.isSubmitting) return;
            practiceState.isSubmitting = true;

            if (!practiceState.questions || !practiceState.questions[practiceState.currentIndex]) {
                console.error('No current question found');
                practiceState.isSubmitting = false;
                return;
            }

            const question = practiceState.questions[practiceState.currentIndex];
            const userAnswer = document.getElementById('practiceAnswerInput')?.value.toLowerCase().trim() || '';
            const correctAnswer = question.answer.replace(/<[^>]+>/g, '').toLowerCase();
            
            // Clear any existing result divs
            const existingResults = document.querySelectorAll('.practice-result');
            existingResults.forEach(el => el.remove());
            
            // Show full question
            const displayElement = document.getElementById('practiceQuestionDisplay');
            if (displayElement) {
                displayElement.innerHTML = question.question;
            }
            
            const resultDiv = document.createElement('div');
            resultDiv.className = 'practice-result'; // Add class for easy cleanup
            resultDiv.innerHTML = `
                <div class="alert ${userAnswer === correctAnswer ? 'alert-warning' : 'alert-warning'} mt-3">
                    <strong>Correct Answer:</strong> ${question.answer}
                </div>
                <button class="btn btn-primary mt-2" onclick="goToNextPractice()">Next Question (j)</button>
            `;
            
            document.getElementById('practiceModalBody')?.appendChild(resultDiv);

            // Reset submission lock after a delay
            setTimeout(() => {
                practiceState.isSubmitting = false;
            }, 500);
        }

        // Add this function to handle main button states
        function updateMainButtonStates(disable) {
            const mainButtons = ['buzz', 'submit', 'next'].forEach(id => {
                const button = document.getElementById(id);
                if (button) {
                    button.disabled = disable;
                    button.style.opacity = disable ? '0.5' : '1';
                }
            });
        }

        // Main event listener for keyboard shortcuts
        document.addEventListener('keydown', (e) => {
    const practiceModal = document.getElementById('practiceModal');
    const isPracticeModalOpen = practiceModal?.classList.contains('show');
    const searchInput = document.getElementById('searchInput');
    const practiceAnswerInput = document.getElementById('practiceAnswerInput');
    
    // If typing in any input field, allow default behavior
    if (document.activeElement.tagName === 'INPUT') {
        // Only handle Enter for submission in practice mode
        if (isPracticeModalOpen && e.code === 'Enter' && !e.repeat && practiceState.isBuzzed) {
            e.preventDefault();
            submitPracticeAnswer();
        }
        return; // Allow all other keys when typing in inputs
    }
    
    // Handle practice mode shortcuts when not typing
    if (isPracticeModalOpen) {
        if (e.code === 'Space' && !e.repeat) {
            e.preventDefault();
            if (!practiceState.isBuzzed) handlePracticeBuzz();
        } else if (e.code === 'Enter' && !e.repeat) {
            if (practiceState.isBuzzed) submitPracticeAnswer();
        } else if (e.code === 'KeyJ' && !e.repeat) {
            const nextBtn = document.querySelector('[onclick="goToNextPractice()"]');
            if (nextBtn) goToNextPractice();
        }
    }
});


        function goToNextPractice() {
            const nextIndex = getNextPracticeIndex();
            
            if (nextIndex === -1) {
                return; // Practice session complete
            }
            
            practiceState.currentIndex = nextIndex;
            practiceState.isBuzzed = false;
            showPracticeQuestion(practiceState.questions[practiceState.currentIndex]);
        }

        function startPractice(selectedQuestions) {
            if (!selectedQuestions || selectedQuestions.length === 0) {
                console.error('No questions selected for practice');
                return;
            }
            
            // Initialize practice state with selected questions
            practiceState = {
                questions: selectedQuestions,
                currentIndex: 0,
                unseenQuestions: [...Array(selectedQuestions.length).keys()],
                words: [],
                wordIndex: 0,
                interval: null,
                isBuzzed: false,
                speed: document.getElementById('practiceSpeed')?.value || 500
            };

            // Get first random question
            const randomIndex = Math.floor(Math.random() * practiceState.unseenQuestions.length);
            practiceState.currentIndex = practiceState.unseenQuestions[randomIndex];
            practiceState.unseenQuestions.splice(randomIndex, 1);
            
            // Show practice modal
            $('#practiceModal').modal('show');
            
            // Show first question
            showPracticeQuestion(practiceState.questions[practiceState.currentIndex]);
        }

        function handlePracticeClick() {
            const selectedQuestions = JSON.parse(localStorage.getItem('practiceQuestions'));
            if (!selectedQuestions || selectedQuestions.length === 0) {
                alert('Please select questions to practice first');
                return;
            }
            
            $('#resultsModal').modal('hide');
            startPractice(selectedQuestions);
        }

        function getNextPracticeIndex() {
            if (!practiceState.unseenQuestions || practiceState.unseenQuestions.length === 0) {
                // No more unseen questions, practice session complete
                document.getElementById('practiceModalBody').innerHTML = `
                    <div class="alert alert-success">
                        Practice session complete! You've gone through all ${practiceState.questions.length} selected questions.
                    </div>`;
                return -1;
            }
            
            // Get random index from remaining unseen questions
            const randomIndex = Math.floor(Math.random() * practiceState.unseenQuestions.length);
            const nextQuestionIndex = practiceState.unseenQuestions[randomIndex];
            // Remove this index from unseenQuestions
            practiceState.unseenQuestions.splice(randomIndex, 1);
            
            return nextQuestionIndex;
        }



        async function loadTrainingQuestion() {
            try {
                const response = await fetch('/api/random-question');
                const question = await response.json();
                
                document.getElementById('trainingQuestion').textContent = question.question.replace(/<[^>]+>/g, '');
                document.getElementById('correctAnswer').textContent = question.answer.replace(/<[^>]+>/g, '');
                document.getElementById('trainingAnswer').value = '';
                
                currentTrainingQuestion = question;
            } catch (error) {
                console.error('Error loading training question:', error);
            }
        }

        async function markAnswer(isCorrect) {
            const userAnswer = document.getElementById('trainingAnswer').value;
            if (!userAnswer.trim()) {
                alert('Please enter an answer before marking');
                return;
            }
            
            const correctAnswer = currentTrainingQuestion.answer;
            
            try {
                await fetch('/api/train-answer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userAnswer,
                        correctAnswer,
                        isCorrect
                    })
                });
                
                // Show feedback
                const feedback = document.createElement('div');
                feedback.className = `alert alert-${isCorrect ? 'success' : 'danger'} mt-2`;
                feedback.textContent = `Answer marked as ${isCorrect ? 'correct' : 'incorrect'}`;
                document.querySelector('.modal-body').appendChild(feedback);
                
                // Remove feedback after 2 seconds
                setTimeout(() => feedback.remove(), 2000);
                
                // Load next question
                loadTrainingQuestion();
            } catch (error) {
                console.error('Error saving training data:', error);
            }
        }

        // Add after answer submission handling
        function showTrainingOption() {
            document.getElementById('training-container').style.display = 'block';
            document.getElementById('trainAnswers').addEventListener('click', () => {
                const modal = $('#trainAnswersModal');
                document.getElementById('train-question-text').textContent = 
                    currentQuestion.question.replace(/<[^>]+>/g, '');
                document.getElementById('train-correct-answer').textContent = 
                    currentQuestion.answer.replace(/<[^>]+>/g, '');
                modal.modal('show');
            });
        }

        async function submitAlternativeAnswer() {
            const altAnswer = document.getElementById('alternativeAnswer').value.trim();
            if (!altAnswer) return;

            try {
                await fetch('/api/train-answer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        userAnswer: altAnswer,
                        correctAnswer: currentQuestion.answer,
                        isCorrect: true
                    })
                });

                // Add to trained answers list
                const li = document.createElement('li');
                li.className = 'list-group-item';
                li.textContent = altAnswer;
                document.getElementById('trained-answers-list').appendChild(li);

                // Clear input
                document.getElementById('alternativeAnswer').value = '';

            } catch (error) {
                console.error('Error saving alternative answer:', error);
            }
        }

        let hasBeenPrompted = false;

        // Add hover stats functionality
        async function showMissedQuestions() {
            if (!window.auth?.currentUser) return;
            
            try {
                const userRef = window.db.ref('users/' + window.auth.currentUser.uid);
                userRef.child('progress/history').once('value', (snapshot) => {
                    const history = snapshot.val() || [];
                    const missedQuestions = history.filter(entry => !entry.isCorrect);
                    
                    if (missedQuestions.length > 0) {
                        const missedHTML = `
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <div>
                                    <button class="btn btn-primary me-2" onclick="practiceMissedQuestions()">
                                        Practice Selected Questions
                                    </button>
                                    <button class="btn btn-secondary" onclick="toggleAllMissed()">
                                        Toggle Selection
                                    </button>
                                </div>
                                <span id="missedSelectedCount" class="text-muted"></span>
                            </div>
                            ${missedQuestions.map((entry, index) => `
                                <div class="missed-question-item mb-2">
                                    <div class="form-check">
                                        <input type="checkbox" class="form-check-input" id="missed-${index}">
                                        <label class="form-check-label" for="missed-${index}">
                                            <div class="question-text">${entry.question}</div>
                                            <div class="answer-section">
                                                <div>Your answer: ${entry.userAnswer}</div>
                                                <div>Correct answer: ${entry.answer.replace(/<\/?[^>]+(>|$)/g, '')}</div>
                                            </div>
                                        </label>
                                    </div>
                                </div>
                            `).join('')}
                        `;
                        
                        document.getElementById('missedQuestionsList').innerHTML = missedHTML;
                        updateMissedSelectedCount();
                    } else {
                        document.getElementById('missedQuestionsList').innerHTML = 'No missed questions found.';
                    }
                    
                    $('#missedQuestionsModal').modal('show');
                });
            } catch (error) {
                console.error("Error loading missed questions:", error);
            }
        }

        function toggleAllMissed() {
            const checkboxes = document.querySelectorAll('#missedQuestionsList input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
            updateMissedSelectedCount();
        }

        function updateMissedSelectedCount() {
            const total = document.querySelectorAll('#missedQuestionsList input[type="checkbox"]').length;
            const selected = document.querySelectorAll('#missedQuestionsList input[type="checkbox"]:checked').length;
            document.getElementById('missedSelectedCount').textContent = `${selected}/${total} selected`;
        }

        function practiceMissedQuestions() {
    const checkboxes = document.querySelectorAll('#missedQuestionsList input[type="checkbox"]:checked');
    if (checkboxes.length === 0) return;
    
    const selectedQuestions = Array.from(checkboxes).map(cb => {
        const questionItem = cb.closest('.missed-question-item');
        return {
            question: questionItem.querySelector('.question-text').textContent,
            answer: questionItem.querySelector('.answer-section').lastElementChild.textContent.replace('Correct answer: ', ''),
            setName: 'Missed Question'
        };
    });
    
    $('#missedQuestionsModal').modal('hide');
    startPractice(selectedQuestions);
}

// Update the missed questions display HTML (around line 3081):
const missedHTML = `
    <div class="d-flex justify-content-between align-items-center mb-3">
        <div>
            <button class="btn btn-primary me-2" onclick="practiceMissedQuestions()">
                Practice Selected Questions
            </button>
            <button class="btn btn-secondary" onclick="toggleAllMissed()">
                Toggle Selection
            </button>
        </div>
        <span id="missedSelectedCount" class="text-muted"></span>
    </div>
    ${missedQuestions.map((entry, index) => `
        <div class="missed-question-item mb-2">
            <div class="card bg-light-red">
                <div class="card-body">
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input" id="missed-${index}">
                        <label class="form-check-label" for="missed-${index}">
                            <div class="question-text">${entry.question}</div>
                            <div class="answer-section">
                                <div>Your answer: ${entry.userAnswer}</div>
                                <div>Correct answer: ${entry.answer.replace(/<\/?[^>]+(>|$)/g, '')}</div>
                            </div>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    `).join('')}
`;

        // Update the existing onAuthStateChanged listener to include accuracy stats
        window.auth.onAuthStateChanged(async (user) => {
            if (user) {
                const userRef = window.db.ref('users/' + user.uid);
                userRef.on('value', (snapshot) => {
                    const userData = snapshot.val() || { 
                        progress: { correctAnswers: 0, questionsAnswered: 0 },
                        username: 'User'
                    };
                    
                    // Calculate accuracy
                    const accuracy = userData.progress?.questionsAnswered ? 
                        ((userData.progress.correctAnswers / userData.progress.questionsAnswered) * 100).toFixed(1) : 
                        0;
                    
                    // Update username with dropdown
                    if (usernameDisplay) {
                        usernameDisplay.innerHTML = `
                            <div class="username-dropdown">
                                ${userData.username || 'User'}
                                <div class="dropdown-content">
                                    <div class="stats-item">
                                        Accuracy: ${accuracy}%
                                    </div>
                                    <div class="stats-item">
                                        Total Questions: ${userData.progress?.questionsAnswered || 0}
                                    </div>
                                    <button class="view-missed-btn" onclick="showMissedQuestions()">
                                        View Missed Questions
                                    </button>
                                </div>
                            </div>`;
                    }
                });
            }
        });

        // Function to parse third.txt format questions
        function parseThirdQuestions(data) {
            const lines = data.split('\n');
            const questionSets = [];
            let currentSet = [];
            let currentCategory = '';
            
            lines.forEach(line => {
                if (!line.trim()) return;
                
                const [num, questionText] = line.split('|');
                const [question, answer] = questionText.split('\t');
                
                // If it's the first question of a set (ends with 1))
                if (num.endsWith('1)')) {
                    if (currentSet.length > 0) {
                        questionSets.push({
                            category: currentCategory,
                            questions: currentSet
                        });
                    }
                    currentSet = [];
                    // Extract category from the question text
                    currentCategory = question.split('Concerning ')[1]?.split(',')[0] || 
                                    question.split('Name the...')[0] || 
                                    question.split('What...')[0] || 
                                    'Miscellaneous';
                }
                
                currentSet.push({
                    question: question.trim(),
                    answer: answer.trim()
                });
            });
            
            // Add the last set
            if (currentSet.length > 0) {
                questionSets.push({
                    category: currentCategory,
                    questions: currentSet
                });
            }
            
            return questionSets;
        }

        // Function to get a random question set
        /*
        function getRandomThirdQuestionSet(questionSets) {
            const randomIndex = Math.floor(Math.random() * questionSets.length);
            return questionSets[randomIndex];
        }

        // Add this to your existing initialization code
        fetch('thirdQuarter/third.txt')
            .then(response => response.text())
            .then(data => {
                window.thirdQuestions = parseThirdQuestions(data);
                
                // Add option to dropdown
                const dropdown = document.getElementById('questionSetSelect');
                const option = document.createElement('option');
                option.value = 'third';
                option.textContent = 'Third Quarter Questions';
                dropdown.appendChild(option);
            });
*/
        // Modify your existing question set selection handler
        function handleQuestionSetChange(event) {
            const selectedValue = event.target.value;
            if (selectedValue === 'third') {
                const randomSet = getRandomThirdQuestionSet(window.thirdQuestions);
                currentQuestions = randomSet.questions;
                document.getElementById('categoryTitle').textContent = `Category: ${randomSet.category}`;
                resetGame();
            } else {
                // Your existing question set handling code
            }
        }

        function filterQuestionsBySelectedSets(selectedValues) {
            if (selectedValues.includes('all')) {
                return allQuestions;
            }

            return allQuestions.filter(q => {
                if (selectedValues.includes('bowl-nationals') && q.setName.toLowerCase().includes('nationals') && !q.isBeeset) {
                    return true;
                }
                if (selectedValues.includes('bowl-regionals') && q.setName.toLowerCase().includes('regionals') && !q.isBeeset) {
                    return true;
                }
                if (selectedValues.includes('bee-nationals') && q.setName.toLowerCase().includes('nationals') && q.isBeeset) {
                    return true;
                }
                if (selectedValues.includes('bee-regionals') && q.setName.toLowerCase().includes('regionals') && q.isBeeset) {
                    return true;
                }
                if (selectedValues.includes('third-quarter') && q.setName.toLowerCase().includes('third quarter')) {
                    return true;
                }
                return false;
            });
        }

        // Modify the existing event listener for setType
        document.getElementById('setType').addEventListener('change', function() {
            const selectedValues = Array.from(this.selectedOptions).map(option => option.value);
            const filteredQuestions = filterQuestionsBySelectedSets(selectedValues);
            
            if (filteredQuestions.length === 0) {
                alert('Please select at least one question set');
                return;
            }

            // Update the available questions
            currentQuestions = filteredQuestions;
            
            // Update the question count display
            const countDisplay = document.querySelector('.question-count');
            if (countDisplay) {
                countDisplay.textContent = `${filteredQuestions.length} questions available`;
            }

            resetGame();
        });

        // Initialize when page loads
        window.addEventListener('load', async () => {
            await preloadQuestions();
            
            // Pre-select 'all' option
            const setTypeSelect = document.getElementById('setType');
            const allOption = Array.from(setTypeSelect.options).find(option => option.value === 'all');
            if (allOption) {
                allOption.selected = true;
            }

            // Add start button click handler
            document.getElementById('startButton').addEventListener('click', () => {
                document.getElementById('startButton').style.display = 'none';
                fetchQuestion();
            });
        });

        function showSearchConfirm(event, selectedText) {
            const searchConfirm = document.querySelector('.search-confirm');
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            
            // Position the popup relative to the highlighted text
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            searchConfirm.style.top = `${rect.bottom + scrollTop + 10}px`;
            searchConfirm.style.left = `${Math.min(rect.left + scrollLeft, window.innerWidth - 320)}px`;
            
            // Update content and show
            searchConfirm.querySelector('.selected-text').textContent = selectedText;
            searchConfirm.style.display = 'block';
            
            // Ensure popup is fully visible
            const popupRect = searchConfirm.getBoundingClientRect();
            if (popupRect.right > window.innerWidth) {
                searchConfirm.style.left = `${window.innerWidth - popupRect.width - 20}px`;
            }
            if (popupRect.bottom > window.innerHeight) {
                searchConfirm.style.top = `${rect.top + scrollTop - popupRect.height - 10}px`;
            }
        }

        // Add this function to handle TTS
        function readQuestionWithTTS(question) {
            if (speechUtterance) {
                speechSynthesis.cancel();
            }
            
            if (isTTSEnabled) {
                speechUtterance = new SpeechSynthesisUtterance(question);
                const speed = document.getElementById('speed').value;
                speechUtterance.rate = 800 / speed; // Adjust rate based on word display speed
                speechSynthesis.speak(speechUtterance);
            }
        }



        // Add cleanup for TTS when stopping question
        function stopQuestion() {
            if (intervalId) {
                clearInterval(intervalId);
            }
            if (speechUtterance) {
                speechSynthesis.cancel();
            }
        }

        // Initialize TTS
        document.addEventListener('DOMContentLoaded', () => {
            const ttsToggle = document.getElementById('ttsToggle');
            if (!ttsToggle) return;
            
            // Check for saved preference
            isTTSEnabled = localStorage.getItem('ttsEnabled') === 'true';
            
            // Set initial state
            if (isTTSEnabled) {
                ttsToggle.innerHTML = '🔊 TTS On';
                ttsToggle.classList.add('active');
            }
            
            ttsToggle.addEventListener('click', () => {
                isTTSEnabled = !isTTSEnabled;
                localStorage.setItem('ttsEnabled', isTTSEnabled);
                
                // Cancel any ongoing speech when turning off
                if (!isTTSEnabled && speechUtterance) {
                    window.speechSynthesis.cancel();
                }
                
                // Update button text and style
                ttsToggle.innerHTML = isTTSEnabled ? '🔊 TTS On' : '🔊 TTS Off';
                ttsToggle.classList.toggle('active', isTTSEnabled);
                
                console.log('TTS Enabled:', isTTSEnabled); // Debug line
            });
        });

        // Add this function for TTS
        function readQuestionWithTTS(text) {
            if (!isTTSEnabled) return;
            
            // Cancel any ongoing speech
            if (speechUtterance) {
                window.speechSynthesis.cancel();
            }
            
            speechUtterance = new SpeechSynthesisUtterance(text);
            const speed = document.getElementById('speed').value;
            speechUtterance.rate = 800 / speed; // Adjust rate based on word display speed
            window.speechSynthesis.speak(speechUtterance);
        }

        async function searchQBReader(searchInput, searchType) {
            try {
                const LIMIT = 25;
                let allQuestions = new Set();
                
                // Split by commas for multiple searches
                const searchTerms = searchInput.split(',').map(term => term.trim()).filter(term => term.length > 0);
                
                for (const term of searchTerms) {
                    let offset = 0;
                    const initialResponse = await fetch(
                        `https://www.qbreader.org/api/query?queryString=${encodeURIComponent(term)}&questionType=tossup`
                    );
                    const initialData = await initialResponse.json();
                    
                    if (!initialData?.tossups?.count) continue;

                    const totalQuestions = initialData.tossups.count;
                    initialData.tossups.questionArray.forEach(q => allQuestions.add(JSON.stringify(q)));

                    while (offset + LIMIT < totalQuestions) {
                        offset += LIMIT;
                        const response = await fetch(
                            `https://www.qbreader.org/api/query?queryString=${encodeURIComponent(term)}&questionType=tossup&offset=${offset}`
                        );
                        const data = await response.json();
                        data.tossups.questionArray.forEach(q => allQuestions.add(JSON.stringify(q)));
                    }
                }

                const questions = Array.from(allQuestions).map(q => JSON.parse(q)).filter(q => {
                    const questionText = (q.question_sanitized || q.question || '').toLowerCase();
                    const answerText = (q.answer_sanitized || q.answer || '').toLowerCase();
                    
                    if (searchType === 'question') {
                        return questionText.includes(searchInput.toLowerCase());
                    } else if (searchType === 'answer') {
                        return answerText.includes(searchInput.toLowerCase());
                    }
                    return questionText.includes(searchInput.toLowerCase()) || answerText.includes(searchInput.toLowerCase());
                });

                return questions.map(q => ({
                    question: q.question_sanitized || q.question,
                    answer: q.answer_sanitized || q.answer,
                    isQBReader: true,
                    setName: `${q.set?.name || 'Unknown Set'} (${q.set?.year || 'Unknown Year'})`
                }));

            } catch (error) {
                console.error('QB Reader fetch error:', error);
                return [];
            }
        }

        function closeQBResults(event) {
            if (event.target.classList.contains('qb-reader-overlay') || 
                event.target.classList.contains('close-btn')) {
                const overlay = document.querySelector('.qb-reader-overlay');
                if (overlay) overlay.remove();
            }
        }

        // Add escape key handler to close results
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const overlay = document.querySelector('.qb-reader-overlay');
                if (overlay) overlay.remove();
            }
        });

        document.getElementById('searchResults').addEventListener('change', function(e) {
            if (e.target.type === 'checkbox') {
                updateSelectedCount();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            // Add checkbox change listener for search results
            document.getElementById('searchResults').addEventListener('change', function(e) {
                if (e.target.type === 'checkbox') {
                    updateSelectedCount();
                }
            });
            
            // Add toggle all questions listener
            document.getElementById('toggleAll')?.addEventListener('click', function() {
                const checkboxes = document.querySelectorAll('#searchResults input[type="checkbox"]');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                checkboxes.forEach(cb => cb.checked = !allChecked);
                updateSelectedCount();
            });
        });

        async function analyzeUserPerformance() {
            if (!window.auth?.currentUser) return null;
            
            try {
                const userRef = window.db.ref(`users/${window.auth.currentUser.uid}`);
                const snapshot = await userRef.child('progress/history').once('value');
                const history = snapshot.val() || [];
                
                const analysis = {
                    totalQuestions: history.length,
                    correctCount: 0,
                    categories: {},  // Will store category stats
                    missedQuestions: {} // Will store missed questions by category
                };
                
                // Process each question in history
                history.forEach(entry => {
                    const category = entry.metadata?.category || 'Uncategorized';
                    
                    // Initialize category if not exists
                    if (!analysis.categories[category]) {
                        analysis.categories[category] = {
                            total: 0,
                            correct: 0,
                            successRate: 0
                        };
                    }
                    if (!analysis.missedQuestions[category]) {
                        analysis.missedQuestions[category] = [];
                    }
                    
                    // Update stats
                    analysis.categories[category].total++;
                    if (entry.isCorrect) {
                        analysis.categories[category].correct++;
                        analysis.correctCount++;
                    } else {
                        // Store missed question
                        analysis.missedQuestions[category].push({
                            question: entry.question,
                            answer: entry.answer,
                            userAnswer: entry.userAnswer,
                            setName: entry.setName
                        });
                    }
                    
                    // Calculate success rate
                    analysis.categories[category].successRate = 
                        (analysis.categories[category].correct / analysis.categories[category].total) * 100;
                });
                
                // Sort categories by success rate
                const sortedCategories = Object.entries(analysis.categories)
                    .filter(([_, stats]) => stats.total >= 5) // Only categories with 5+ questions
                    .sort((a, b) => a[1].successRate - b[1].successRate) // Sort by success rate ascending
                    .reduce((acc, [category, stats]) => {
                        acc[category] = {
                            ...stats,
                            missedQuestions: analysis.missedQuestions[category] || []
                        };
                        return acc;
                    }, {});
                
                analysis.sortedCategories = sortedCategories;
                return analysis;
            } catch (error) {
                console.error('Error analyzing performance:', error);
                return null;
            }
        }

        function displayPerformanceAnalysis(analysis) {
            if (!analysis) return;
            
            const analysisHTML = `
                <div class="analysis-container">
                    <div class="overall-stats mb-4">
                        <h6>Overall Performance</h6>
                        <div class="card bg-light">
                            <div class="card-body">
                                <p class="mb-2">Success Rate: ${((analysis.correctCount / analysis.totalQuestions) * 100).toFixed(1)}%</p>
                                <p class="mb-0">Total Questions Answered: ${analysis.totalQuestions}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="categories-section">
                        <h6>Category Performance</h6>
                        ${Object.entries(analysis.sortedCategories).map(([category, stats]) => `
                            <div class="category-card mb-3">
                                <div class="card">
                                    <div class="card-body">
                                        <h6 class="card-title d-flex justify-content-between">
                                            <span>${category}</span>
                                            <span class="badge ${stats.successRate < 60 ? 'bg-danger' : 'bg-success'}">
                                                ${stats.successRate.toFixed(1)}%
                                            </span>
                                        </h6>
                                        <p class="mb-2">Questions: ${stats.total} (${stats.correct} correct)</p>
                                        ${stats.missedQuestions.length > 0 ? `
                                            <div class="missed-questions mt-3">
                                                <button class="btn btn-sm btn-outline-primary mb-2" 
                                                    onclick="practiceCategory('${category}')">
                                                    Practice Missed Questions
                                                </button>
                                                <div class="missed-list small">
                                                    ${stats.missedQuestions.slice(0, 3).map(q => `
                                                        <div class="missed-item">
                                                            <strong>Q:</strong> ${q.question.substring(0, 100)}...
                                                            <br>
                                                            <strong>A:</strong> ${q.answer}
                                                        </div>
                                                    `).join('')}
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            document.getElementById('analysisContent').innerHTML = analysisHTML;
        }

        function practiceCategory(category) {
            const analysis = JSON.parse(localStorage.getItem('currentAnalysis'));
            if (!analysis?.sortedCategories[category]?.missedQuestions) return;
            
            const missedQuestions = analysis.sortedCategories[category].missedQuestions;
            selectedQuestions = missedQuestions;
            
            $('#analysisModal').modal('hide');
            practiceSelectedQuestions();
        }

        window.auth.onAuthStateChanged(async (user) => {
            if (user) {
                const analysis = await analyzeUserPerformance();
                displayPerformanceAnalysis(analysis);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            // Add analysis button click handler
            document.getElementById('showAnalysis').addEventListener('click', async () => {
                const analysis = await analyzeUserPerformance();
                if (analysis) {
                    displayPerformanceAnalysis(analysis);
                    $('#analysisModal').modal('show');
                } else {
                    alert('Please sign in to view your performance analysis.');
                }
            });
        });

        async function showPerformanceAnalysis() {
            const analysis = await analyzeUserPerformance();
            if (analysis) {
                displayPerformanceAnalysis(analysis);
                $('#analysisModal').modal('show');
            } else {
                alert('Please sign in to view your performance analysis.');
            }
        }
    </script>

    <!-- Search Modal -->
    <div class="modal fade" id="searchModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Search Questions</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <input type="text" id="searchInput" class="form-control" placeholder="Search for terms...">
                    <br>
                    <div class="btn-group btn-group-toggle mb-3" data-toggle="buttons">
                        <label class="btn btn-outline-primary active">
                            <input type="radio" name="searchType" value="both" checked> Both
                        </label>
                        <label class="btn btn-outline-primary">
                            <input type="radio" name="searchType" value="question"> Questions Only
                        </label>
                        <label class="btn btn-outline-primary">
                            <input type="radio" name="searchType" value="answer"> Answers Only
                        </label>
                    </div>
                    <div class="form-check mb-3">
                        <input class="form-check-input" type="checkbox" id="includeQbreader" checked>
                        <label class="form-check-label" for="includeQbreader">
                            Include QBreader Results
                        </label>
                    </div>
                    <button class="btn btn-primary mt-3" onclick="searchQuestions()">Search</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Modal -->
    <div class="modal fade" id="resultsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Search Results</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div>
                            <button class="btn btn-primary me-2" onclick="practiceSelectedQuestions()">
                                Practice Selected Questions
                            </button>
                            <button class="btn btn-secondary" onclick="toggleAllQuestions()">
                                Toggle Selection
                            </button>
                        </div>
                        <span id="selectedCount" class="text-muted"></span>
                    </div>
                    <div id="searchResults"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div class="modal fade" id="authModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Sign In / Sign Up</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <input type="email" id="authEmail" class="form-control mb-2" placeholder="Email">
                        <input type="password" id="authPassword" class="form-control mb-2" placeholder="Password">
                        <input type="text" id="authUsername" class="form-control mb-2" placeholder="Username">
                        <div class="btn-group w-100">
                            <button onclick="handleSignIn()" class="btn btn-primary">Sign In</button>
                            <button onclick="handleSignUp()" class="btn btn-secondary">Sign Up</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div class="modal fade" id="leaderboardModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Top 100 Players</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div id="leaderboardList" class="list-group">
                        <!-- Leaderboard entries will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Practice Modal -->
    <div class="modal fade practice-modal" id="practiceModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Practice Selected Questions</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="practiceModalBody">
                    <div id="practiceQuestion"></div>
                    <div id="practiceControls" class="mt-3">
                        <button class="btn btn-primary" onclick="nextPracticeQuestion()">Next Question</button>
                    </div>
                </div>
            </div>
        </div>
    </div>




    <!-- Training Answers Modal -->
    <div class="modal fade" id="trainAnswersModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Train Alternative Answers</h5>
                    <button type="button" class="close" data-dismiss="modal">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <strong>Question:</strong>
                        <p id="train-question-text"></p>
                        <strong>Correct Answer:</strong>
                        <p id="train-correct-answer"></p>
                    </div>
                    <div class="input-group mb-3">
                        <input type="text" class="form-control" id="alternativeAnswer" 
                               placeholder="Enter another valid answer">
                        <div class="input-group-append">
                            <button class="btn btn-success" onclick="submitAlternativeAnswer()">Add as Valid</button>
                        </div>
                    </div>
                    <div id="trained-answers" class="mt-3">
                        <strong>Trained Answers:</strong>
                        <ul class="list-group" id="trained-answers-list"></ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this modal for missed questions -->
    <div class="modal fade" id="missedQuestionsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Missed Questions</h5>
                    <button type="button" class="close" data-dismiss="modal">&times;</button>
                </div>
                <div class="modal-body">
                    <div id="missedQuestionsList"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="analysisSection" class="mt-4"></div>


    <!-- Add Analysis Modal -->
    <div class="modal fade" id="analysisModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Performance Analysis</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="analysisContent"></div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>