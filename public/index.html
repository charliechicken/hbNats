<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>History Bowl</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
        
        <!-- Firebase SDKs -->
        <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
        <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
    
        <script>
        // Wait for Firebase SDKs to load
        window.onload = function() {
            // Firebase configuration
            const firebaseConfig = {
                apiKey: "AIzaSyA_bM4yUQkO0ZPowDtfysAhIU7YmNsHmQc",
                authDomain: "historybowl-4440f.firebaseapp.com",
                projectId: "historybowl-4440f",
                databaseURL: "https://historybowl-4440f-default-rtdb.firebaseio.com"
            };

            // Initialize Firebase
            firebase.initializeApp(firebaseConfig);

            // Make Firebase services available globally
            window.auth = firebase.auth();
            window.db = firebase.database();

            // Add debug logging
            console.log('Firebase initialized');
            window.auth.onAuthStateChanged((user) => {
                console.log('Auth state changed:', user ? user.uid : 'logged out');
            });
            
            // Test Firebase connection
            window.db.ref().once('value')
                .then(() => console.log('Realtime Database connected'))
                .catch(error => console.error('Database error:', error));

            // Auth state observer
            window.auth.onAuthStateChanged(async (user) => {
                const authButton = document.getElementById('authButton');
                const userStats = document.getElementById('userStats');
                const usernameDisplay = document.getElementById('usernameDisplay');
                
                if (user) {
                    authButton.textContent = 'Sign Out';
                    userStats.style.display = 'block';
                    
                    // Listen for realtime updates
                    const userRef = window.db.ref('users/' + user.uid);
                    userRef.on('value', (snapshot) => {
                        const userData = snapshot.val() || { 
                            progress: { correctAnswers: 0, questionsAnswered: 0 },
                            username: 'User'
                        };
                        document.getElementById('correctCount').textContent = userData.progress.correctAnswers;
                        document.getElementById('totalCount').textContent = userData.progress.questionsAnswered;
                        usernameDisplay.textContent = userData.username;
                    });
                } else {
                    authButton.textContent = 'Sign In';
                    userStats.style.display = 'none';
                    usernameDisplay.textContent = '';
                }
            });
        };

        // Firebase helper functions
        async function loadUserProgress(userId) {
            try {
                const userRef = window.db.ref('users/' + userId);
                const snapshot = await userRef.once('value');
                const data = snapshot.val();
                
                if (data?.progress?.history) {
                    const historyDiv = document.getElementById('questionHistory');
                    historyDiv.style.display = 'block';  // Make sure history is visible
                    historyDiv.innerHTML = '';  // Clear existing history
                    
                    // Add each history entry as a card
                    data.progress.history.forEach(entry => {
                        const card = document.createElement('div');
                        card.className = `history-card ${entry.isCorrect ? 'correct' : 'incorrect'}`;
                        
                        card.innerHTML = `
                            <div class="question-text">${entry.question}</div>
                            <div class="answer-section">
                                <div>
                                    <span class="user-answer">Your answer: ${entry.userAnswer}</span>
                                </div>
                                <div>
                                    <span class="correct-answer">Correct answer: ${entry.answer.replace(/<\/?[^>]+(>|$)/g, '')}</span>
                                </div>
                            </div>
                        `;
                        
                        historyDiv.appendChild(card);
                    });
                }
            } catch (error) {
                console.error("Error loading progress:", error);
            }
        }

        async function saveUserProgress(questionData) {
    const user = window.auth.currentUser;
    if (!user) return;

    try {
        const userRef = window.db.ref('users/' + user.uid);
        
        // Get current data
        const snapshot = await userRef.once('value');
        const currentData = snapshot.val() || {
            email: user.email,
            username: '',
            progress: {
                questionsAnswered: 0,
                correctAnswers: 0,
                history: []
            }
        };

        // Update progress while preserving username
        const updatedProgress = {
            questionsAnswered: (currentData.progress.questionsAnswered || 0) + 1,
            correctAnswers: (currentData.progress.correctAnswers || 0) + (questionData.isCorrect ? 1 : 0),
            history: [questionData, ...(currentData.progress.history || []).slice(0, 49)]
        };

        // Save to database
        await userRef.set({
            email: user.email,
            username: currentData.username,
            progress: updatedProgress
        });

        console.log('Database updated:', updatedProgress);
    } catch (error) {
        console.error("Error saving to database:", error);
    }
}
        </script>

    <style>
        .badge {
    font-size: 0.9em;
    padding: 0.5em 0.8em;
}

.bg-success {
    background-color: #28a745 !important;
}

.bg-primary {
    background-color: #007bff !important;
}

.me-2 {
            margin-right: 0.5rem !important;
        }

        body {
            background-color: #f0f2f5;
    background-image: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%231a237e' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2V6h4V4H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
}

        .container-fluid {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 15px;
            padding: 15px;
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            color: #1a237e;
            margin-bottom: 2rem;
            font-weight: 600;
        }

        #question {
            margin: 2rem auto;
            font-size: 1.5em;
            padding: 2rem;
            border: none;
            border-radius: 12px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            line-height: 1.8;
        }

        #set-name {
            color: #555;
            font-size: 1.1em;
        }

        #set-name a {
            color: #1565c0;
            text-decoration: none;
        }

        .btn {
            border-radius: 8px;
            padding: 0.5rem 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-danger {
            background-color: #d32f2f;
        }

        .btn-primary {
            background-color: #1976d2;
        }

        .btn-secondary {
            background-color: #455a64;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #answer {
            border-radius: 8px;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
            transition: border-color 0.3s ease;
        }

        #answer:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        #speed {
            width: 200px;
            margin: 0 10px;
        }

        #setType {
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
        }

        #result {
            font-size: 1.2em;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        #questionHistory {
            font-family: 'Inter', sans-serif;
            padding: 1rem;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-top: 2rem;
            max-height: 500px;
            overflow-y: auto;
        }

        .history-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            border-left: 4px solid transparent;
            transition: all 0.2s ease;
        }

        .history-card.correct {
            border-left-color: #28a745;
        }

        .history-card.incorrect {
            border-left-color: #dc3545;
        }

        .history-card:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .history-card .question-text {
            font-size: 0.9em;
            color: #343a40;
            margin-bottom: 8px;
        }

        .history-card .answer-section {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #666;
        }

        .history-card .correct-answer {
            color: #28a745;
            font-weight: 500;
        }

        .history-card .user-answer {
            color: #666;
        }

        .history-card .incorrect .user-answer {
            color: #dc3545;
        }

        .word {
            margin-right: 6px;
            display: inline-block;
        }

        .emphasized {
            color: #ff0000;
            font-weight: 600;
        }


        .word.hidden {
            visibility: hidden;
        }

        .hidden {
            display: none;
        }

        .navbar {
            margin-bottom: .5rem;
            padding: 8px 1rem;
        }

        .modal-dialog.modal-lg {
            max-width: 800px;
        }

        #searchResults .card {
            transition: all 0.3s ease;
        }

        #searchResults .card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        #searchResults {
            max-height: 70vh;
            overflow-y: auto;
        }

        .modal-body {
            max-height: 80vh;
            overflow-y: auto;
        }

        .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
        }

        mark {
            background-color: #fff3cd;
            padding: 0.2em;
            border-radius: 3px;
        }

        .btn-group-toggle .btn {
            margin-right: 5px;
        }

        .btn-group-toggle .btn:last-child {
            margin-right: 0;
        }

        .btn-outline-primary:not(:disabled):not(.disabled).active {
            background-color: #1976d2;
            border-color: #1976d2;
        }

        #categoryType {
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            width: auto;
            min-width: 400px;
            background-color: white;
            font-size: 0.85em;
        }

        #categoryType:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
            outline: none;
        }

        .category-label {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        #questionHistory .mb-3 {
            background-color: #f8f9fa;
            transition: background-color 0.2s ease;
        }

        #questionHistory .mb-3:hover {
            background-color: #f0f0f0;
        }

        /* Enhanced history cards */
        .card {
            border: none;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            animation: slideIn 0.4s ease-out;
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        /* Enhanced result alerts */
        .alert {
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            animation: slideIn 0.3s ease-out;
        }

        .audio-off {
            background-color: #ff4444;
            color: white;
        }

        .audio-on {
            background-color: #00C851;
            color: white;
        }

        .card.history-bowl {
            background-color: #fffff0;  /* Light yellow */
        }

        .card.history-bee {
            background-color: #f8f0ff;  /* Light violet */
        }

        /* Practice mode styles */
        .practice-modal {
            background-color: #f0f2f5;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.4s ease-out;
        }

        .practice-modal .card {
            border: none;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            animation: slideIn 0.4s ease-out;
        }

        .practice-modal .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
        }

        .practice-modal .btn {
            border-radius: 8px;
            padding: 0.5rem 1.5rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .practice-modal .btn-danger {
            background-color: #d32f2f;
        }

        .practice-modal .btn-primary {
            background-color: #1976d2;
        }

        .practice-modal .btn-secondary {
            background-color: #455a64;
        }

        .practice-modal .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .practice-modal #answer {
            border-radius: 8px;
            padding: 12px;
            font-size: 1.1em;
            border: 2px solid #e0e0e0;
            transition: border-color 0.3s ease;
        }

        .practice-modal #answer:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .practice-modal #speed {
            width: 200px;
            margin: 0 10px;
        }

        .practice-modal #result {
            font-size: 1.2em;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .practice-modal .word {
            margin-right: 6px;
            display: inline-block;
        }

        .practice-modal .emphasized {
            color: #ff0000;
            font-weight: 600;
        }

        .practice-modal .word.hidden {
            visibility: hidden;
        }

        .practice-modal .hidden {
            display: none;
        }

        .practice-modal .modal-dialog.modal-lg {
            max-width: 800px;
        }

        .practice-modal #searchResults .card {
            transition: all 0.3s ease;
        }

        .practice-modal #searchResults .card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .practice-modal #searchResults {
            max-height: 70vh;
            overflow-y: auto;
        }

        .practice-modal .modal-body {
            max-height: 80vh;
            overflow-y: auto;
        }

        .practice-modal .loading-spinner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            padding: 2rem;
        }

        .practice-modal .spinner-border {
            width: 3rem;
            height: 3rem;
        }

        .practice-modal mark {
            background-color: #fff3cd;
            padding: 0.2em;
            border-radius: 3px;
        }

        .practice-modal .btn-group-toggle .btn {
            margin-right: 5px;
        }

        .practice-modal .btn-group-toggle .btn:last-child {
            margin-right: 0;
        }

        .practice-modal .btn-outline-primary:not(:disabled):not(.disabled).active {
            background-color: #1976d2;
            border-color: #1976d2;
        }

        .practice-modal #categoryType {
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            width: auto;
            min-width: 400px;
            background-color: white;
            font-size: 0.95em;
            font-family: monospace;
        }

        .practice-modal #categoryType:focus {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
            outline: none;
        }

        .practice-modal .category-label {
            font-size: 0.9em;
            color: #666;
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        .practice-modal #questionHistory .mb-3 {
            background-color: #f8f9fa;
            transition: background-color 0.2s ease;
        }

        .practice-modal #questionHistory .mb-3:hover {
            background-color: #f0f0f0;
        }

        .practice-modal .audio-off {
            background-color: #ff4444;
            color: white;
        }

        .practice-modal .audio-on {
            background-color: #00C851;
            color: white;
        }

        .practice-modal .card.history-bowl {
            background-color: #fffff0;  /* Light yellow */
        }

        .practice-modal .card.history-bee {
            background-color: #f8f0ff;  /* Light violet */
        }

        /* Prevent main page scrolling during practice mode */
        .modal-open {
            overflow: hidden;
        }

        .modal-backdrop.show {
            opacity: 0.5;
        }

        .modal-backdrop.fade {
            opacity: 0;
        }

        .modal-backdrop.show.fade {
            opacity: 0.5;
        }

        .modal-dialog {
            transition: transform 0.3s ease;
        }

        .modal-dialog.show {
            transform: none;
        }

        .modal-dialog.modal-lg {
            max-width: 800px;
        }

        .modal-content {
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            background-color: #f0f2f5;
            border-bottom: 1px solid #e0e0e0;
            padding: 1rem;
        }

        .modal-title {
            font-size: 1.2em;
            font-weight: 600;
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-footer {
            background-color: #f0f2f5;
            border-top: 1px solid #e0e0e0;
            padding: 1rem;
        }

        .modal-footer .btn {
            margin-left: 0.5rem;
        }

        .modal-footer .btn-primary {
            background-color: #1976d2;
            border-color: #1976d2;
        }

        .modal-footer .btn-secondary {
            background-color: #455a64;
            border-color: #455a64;
        }

        .modal-footer .btn-danger {
            background-color: #d32f2f;
            border-color: #d32f2f;
        }

        .modal-footer .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .modal-footer .btn:focus {
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .modal-footer .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .modal-footer .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .modal-footer .btn:disabled:focus {
            box-shadow: none;
        }

        .modal-footer .btn-group {
            margin-right: 0.5rem;
        }

        .modal-footer .btn-group .btn {
            margin-left: 0;
        }

        .modal-footer .btn-group .btn:first-child {
            border-top-left-radius: 8px;
            border-bottom-left-radius: 8px;
        }

        .modal-footer .btn-group .btn:last-child {
            border-top-right-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .modal-footer .btn-group .btn:not(:first-child):not(:last-child) {
            border-radius: 0;
        }

        .modal-footer .btn-group .btn:not(:first-child) {
            margin-left: -1px;
        }

        .modal-footer .btn-group .btn:not(:last-child) {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .modal-footer .btn-group .btn:not(:first-child):not(:last-child) {
            border-radius: 0;
        }

        .badge-pill {
            border-radius: 10rem;
        }

        .list-group-item {
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
        }

        .navbar {
            background-color: #000000 !important; /* Azure */
        }
        
        /* Optional: adjust text color for better contrast */
        .navbar-brand, .navbar-text, .nav-link {
            color: white !important; /* Darker blue for text */
        }
        
        /* Optional: adjust button colors to match theme */
        .navbar .btn-outline-primary {
            color: #2C5282;
            border-color: #2C5282;
        }
        
        .navbar .btn-outline-primary:hover {
            background-color: #2C5282;
            color: #F0F8FF !important;
        }

        .search-tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .search-tooltip .btn-group {
            display: flex;
            gap: 4px;
        }

        .search-tooltip .btn {
            padding: 4px 8px;
            font-size: 0.9em;
        }

        .container-fluid {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 15px;
            padding: 15px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .question-container {
            grid-column: 1;
        }

        .controls-container {
            grid-column: 2;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 320px;
            margin-left: auto;
            overflow: hidden;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .control-group select,
        .control-group input {
            font-size: 0.8em;
            width: 100%;
            height: fit-content;
        }

        #question {
            font-size: 1.3em;
            margin: 1rem 0;
        }

        .btn-sm {
            font-size: 0.9em;
            padding: 0.25rem 0.5rem;
        }

        .control-group select {
            font-size: 0.8em;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 8px;
            min-height: 36px;
        }

        .control-group select option {
            font-size: 0.8em;
            white-space: normal;
            word-wrap: break-word;
            padding: 4px;
            max-width: 300px;
        }

        #categoryType {
            width: 100%;
            max-width: 100%;
            padding: 4px 8px;
        }

        #categoryType option {
            font-size: 0.8em;
            padding: 4px 6px;
            max-width: 300px;
            white-space: normal;
            word-wrap: break-word;
        }

        .search-confirm {
            position: fixed;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
        }

        .search-confirm .btn {
            font-size: 0.9em;
            padding: 4px 8px;
            margin: 0 4px;
        }

        .search-confirm .selected-text {
            font-style: italic;
            color: #666;
            margin-bottom: 8px;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .history-card .metadata {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 8px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .history-card .metadata span {
            margin-right: 15px;
        }

        .history-card .set-name,
        .history-card .category {
            font-style: italic;
        }

        .history-card .set-name a {
            color: #1565c0;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .history-card .set-name a:hover {
            color: #003c8f;
            text-decoration: underline;
        }

        .frequency-analysis {
            font-size: 0.9em;
            background-color: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 1rem;
        }

        .frequency-analysis .card-body {
            padding: 0.8rem;
        }

        .frequency-analysis h6 {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .frequency-analysis ul {
            columns: 2;
            font-size: 0.8em;
            margin-bottom: 0;
        }

        .frequency-analysis li {
            padding: 2px 0;
            color: #555;
        }

        .search-result-card {
            font-size: 0.9em;
            margin-bottom: 0.5rem;
        }

        .search-result-card .card-body {
            padding: 0.8rem;
        }

        .search-result-card .card-subtitle {
            font-size: 0.8em;
        }

        .search-result-card .card-text {
            font-size: 0.9em;
            line-height: 1.4;
            margin-top: 0.5rem;
        }

        .search-highlight {
            background-color: #fff3cd;
            padding: 0.1em 0.2em;
            border-radius: 2px;
            margin: 0 -0.2em;
        }

        .search-result-card .card-text mark {
            background-color: #fff3cd;
        }
    </style>
</head>
<body>
    <audio id="buzzSound" src="audio/buzz.mp3"></audio>
    <audio id="correctSound" src="audio/correct.mp3"></audio>
    <audio id="incorrectSound" src="audio/incorrect.mp3"></audio>

    <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <div class="container-fluid">
            <div class="d-flex justify-content-between align-items-center w-100">
                <div class="d-flex align-items-center">
                    <span id="usernameDisplay" class="navbar-text me-3" style="margin-right: 1vw;" color="white !important;"></span>
                    <button id="authButton" class="btn btn-outline-light me-2" 
                            onclick="auth.currentUser ? handleSignOut() : $('#authModal').modal('show')">
                        Sign In
                    </button>
                    <button id="leaderboardButton" class="btn btn-outline-light me-2" onclick="showLeaderboard()">
                        Leaderboard
                    </button>
                    <button class="btn btn-outline-light" onclick="$('#searchModal').modal('show')">
                        Search Questions
                    </button>
                </div>
                <h2 style="color: rgb(200, 255, 255);">LHS History Bowl Practice</h2>
                <div id="userStats" class="text-end" style="display: none;">
                    <span class="badge bg-success me-2">Correct: <span id="correctCount">0</span></span>
                    <span class="badge bg-light">Total Answered: <span id="totalCount">0</span></span>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="question-container">
            <div id="set-name" class="mb-3"></div>
            <div id="question"></div>
            <div class="form-group">
                <input type="text" id="answer" class="form-control mt-3" placeholder="Your answer..." disabled>
                <div id="result"></div>
                <div class="d-flex justify-content-center gap-2 mb-2">
                    <button id="buzz" class="btn btn-danger">Buzz (space)</button>
                    <button id="submit" class="btn btn-primary">Submit (enter)</button>
                    <button id="next" class="btn btn-secondary hidden">Next Question (j)</button>
                </div>
            </div>
            <div class="mt-3">
                <div id="questionHistory" class="history-container"></div>
            </div>
        </div>

        <div class="controls-container">
            <div class="control-group">
                <label for="speed">Reading Speed</label>
                <input type="range" id="speed" min="600" max="1000" value="800">
            </div>

            <div class="control-group">
                <label for="setType">Question Sets</label>
                <select id="setType" class="form-control">
                    <option value="all">All Questions (20,050 questions)</option>
                    <option value="bowl-nationals">History Bowl Nationals (5,187 questions)</option>
                    <option value="bowl-regionals">History Bowl Regionals (8,085 questions)</option>
                    <option value="bee-nationals">History Bee Nationals (2,777 questions)</option>
                    <option value="bee-regionals">History Bee Regionals (4,001 questions)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="categoryType">Category</label>
                <select id="categoryType" class="form-control">
                    <option value="" selected disabled>Select a Category</option>
                    <option value="American History">American History (BN: 878 | BR: 1347 | BeN: 511 | BeR: 812 | Total: 3548)</option>
                    <option value="European History">European History (BN: 587 | BR: 971 | BeN: 378 | BeR: 656 | Total: 2592)</option>
                    <option value="World History">World History (BN: 402 | BR: 672 | BeN: 362 | BeR: 593 | Total: 2029)</option>
                    <option value="Ancient History">Ancient History (BN: 127 | BR: 240 | BeN: 90 | BeR: 164 | Total: 621)</option>
                    <option value="Current Events">Current Events (BN: 135 | BR: 182 | BeN: 50 | BeR: 105 | Total: 472)</option>
                    <option value="Geography">Geography (BN: 81 | BR: 185 | BeN: 59 | BeR: 135 | Total: 460)</option>
                    <option value="Trash">Trash (BN: 86 | BR: 177 | BeN: 45 | BeR: 92 | Total: 400)</option>
                    <option value="Visual Fine Arts">Visual Fine Arts (BN: 76 | BR: 138 | BeN: 37 | BeR: 86 | Total: 337)</option>
                    <option value="Auditory Fine Arts">Auditory Fine Arts (BN: 52 | BR: 122 | BeN: 32 | BeR: 72 | Total: 278)</option>
                    <option value="Other Fine Arts">Other Fine Arts (BN: 62 | BR: 88 | BeN: 29 | BeR: 45 | Total: 224)</option>
                    <option value="Philosophy">Philosophy (BN: 54 | BR: 83 | BeN: 24 | BeR: 44 | Total: 205)</option>
                    <option value="Religion">Religion (BN: 47 | BR: 81 | BeN: 18 | BeR: 48 | Total: 194)</option>
                    <option value="Social Science">Social Science (BN: 46 | BR: 80 | BeN: 17 | BeR: 49 | Total: 192)</option>
                    <option value="American Literature">American Literature (BN: 41 | BR: 60 | BeN: 22 | BeR: 44 | Total: 167)</option>
                    <option value="Mythology">Mythology (BN: 29 | BR: 71 | BeN: 19 | BeR: 37 | Total: 156)</option>
                    <option value="Other Science">Other Science (BN: 26 | BR: 60 | BeN: 9 | BeR: 33 | Total: 128)</option>
                    <option value="British Literature">British Literature (BN: 32 | BR: 42 | BeN: 20 | BeR: 25 | Total: 119)</option>
                    <option value="European Literature">European Literature (BN: 18 | BR: 36 | BeN: 10 | BeR: 19 | Total: 83)</option>
                    <option value="Physics">Physics (BN: 11 | BR: 30 | BeN: 6 | BeR: 20 | Total: 67)</option>
                    <option value="Biology">Biology (BN: 10 | BR: 32 | BeN: 7 | BeR: 8 | Total: 57)</option>
                    <option value="World Literature">World Literature (BN: 16 | BR: 22 | BeN: 9 | BeR: 8 | Total: 55)</option>
                    <option value="Chemistry">Chemistry (BN: 8 | BR: 25 | BeN: 5 | BeR: 15 | Total: 53)</option>
                </select>
            </div>

            <div class="control-group">
                <button id="audioToggle" class="btn btn-sm audio-off w-100">ðŸ”ˆ Audio Off</button>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        let currentQuestion = {};
        let currentIndex = 0;
        let words = [];
        let intervalId;
        let audioEnabled = false;
        const answerPlaceholder = document.getElementById('answer');
        answerPlaceholder.style.display = 'none';
        let allQuestions = null;
        let matches = []; // Add this at the top with other global variables

        // Word frequency analyzer with blacklist
        const wordFrequencyAnalyzer = {
            // Common words to ignore by default
            blacklist: new Set([
                'the', 'a', 'an', 'and', 'or', 'but', 'in', 'at', 'to', 'for', 'with',
                'by', 'from', 'up', 'about', 'into', 'over', 'after', 'this', 'that', 'these',
                'those', 'his', 'her', 'their', 'its', 'is', 'was', 'were', 'be', 'been', 'being',
                'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could',
                'who', 'what', 'where', 'when', 'why', 'how', 'ten points', 'points name',
                'man', 'points', 'empire', 'battle', 'war', 'of', 'ten', 'name', 'on', 'city', 'accept', 'which', 'ruler', 'one', 'point', 'as', 'first', 'led', 'he', 'capital', 'during', 'crusade', 'events', 'used', 'prompt on', 'in', 'group in', 'part of', 'of mass', 'under him', 'not prompt on', 'people', 'named', 'prompt', 'new', 'location'
            ]),

            // Words to keep even if they appear in search terms
            exceptions: new Set(['of', 'at', 'on', 'during', 'between', 'crusade']),

            // Single words that should only be blacklisted when they appear alone
            singleWordBlacklist: new Set(['empire', 'battle', 'war']),

            // Two-word phrases that should be blacklisted unless part of longer phrases
            twoWordBlacklist: new Set(['battle of', 'war of', 'empire of', 'siege of', 'site of', 'attack on', 'under him', 'series of', 'republic of', 'leader of', 'treaty of', 'defeat at', 'sack of', 'death of', 'control of', 'fall of', 'plague of', 'holder of', 'before mentioned', 'on partial', 'support of', 'not prompt', 'league of', 'part of', 'civil war', 'world war', 'king of', 'group of', 'author of', 'out of', 'body of', 'war ii', 'kingdom of', 'invasion of', 'most famous', 'son of', 'much of', 'war two', 'form of', 'assassination of', 'act of', 'political party', 'victory at', 'history of', 'island of', 'thousands of', 'holy roman', 'book of', 'council of', 'construction of', 'favor of', 'town of', 'many of', '[prompt on', 'most of', 'i of', 'put down', 'john f', 'word forms', 'raid on', 'portion of', 'two of', 'african country', 'law of', 'scientist proved', 'scientist disproved', 'father of', 'rather than', 'war between', 'fired on', 'surprise attack', 'us president', 'warâ€™s battle', 'two countries']),

            // Add this after the twoWordBlacklist declaration (around line 1176)
            threeWordBlacklist: new Set([
                'battle of the', 'war of the', 'empire of the', 'siege of the', 'site of the',
                'attack on the', 'series of the', 'republic of the', 'leader of the',
                'treaty of the', 'defeat at the', 'sack of the', 'death of the',
                'control of the', 'fall of the', 'plague of the', 'holder of the',
                'league of the', 'part of the', 'king of the', 'group of the',
                'author of the', 'body of the', 'kingdom of the', 'invasion of the',
                'son of the', 'form of the', 'act of the', 'victory at the',
                'history of the', 'island of the', 'council of the', 'town of the',
                'law of the', 'war between the', 'fired on the', 'attack on the', 'warâ€™s battle of'
            ]),

            hasBlacklistedWords(phrase) {
                const words = phrase.split(' ');
                
                // Block phrases containing "prompt on" in that order
                for (let i = 0; i < words.length - 1; i++) {
                    if (words[i].toLowerCase() === 'prompt' && words[i + 1].toLowerCase() === 'on') {
                        return true;
                    }
                }
                
                // For single words
                if (words.length === 1) {
                    const word = words[0];
                    return (this.blacklist.has(word) || this.singleWordBlacklist.has(word)) && !this.exceptions.has(word);
                }
                
                // Block phrases that start with "of" (when it's not the only word)
                if (words.length >= 2 && words[0].toLowerCase() === 'of') {
                    return true;
                }
                
                // For two-word phrases
                if (words.length === 2) {
                    const twoWordPhrase = words.join(' ');
                    if (this.twoWordBlacklist.has(twoWordPhrase)) {
                        return true;
                    }
                }
                
                // For three-word phrases
                if (words.length === 3) {
                    const threeWordPhrase = words.join(' ');
                    if (this.threeWordBlacklist.has(threeWordPhrase)) {
                        return true;
                    }
                }
                
                // For longer phrases, only check regular blacklist words
                // (excluding words in singleWordBlacklist and twoWordBlacklist)
                return words.some(word => 
                    this.blacklist.has(word) && 
                    !this.singleWordBlacklist.has(word) && 
                    !this.exceptions.has(word)
                );
            },

            addToSingleWordBlacklist(...words) {
                words.forEach(word => {
                    this.singleWordBlacklist.add(word.toLowerCase());
                    this.blacklist.add(word.toLowerCase());
                });
            },

            removeFromSingleWordBlacklist(...words) {
                words.forEach(word => {
                    this.singleWordBlacklist.delete(word.toLowerCase());
                    this.blacklist.delete(word.toLowerCase());
                });
            },

            addToTwoWordBlacklist(...phrases) {
                phrases.forEach(phrase => {
                    this.twoWordBlacklist.add(phrase.toLowerCase());
                });
            },

            removeFromTwoWordBlacklist(...phrases) {
                phrases.forEach(phrase => {
                    this.twoWordBlacklist.delete(phrase.toLowerCase());
                });
            },

            analyzeFrequency(texts, searchTerm, maxWords = 10, minFrequency = 2) {
                const frequencies = {
                    words: new Map(),
                    phrases: new Map()
                };

                // Process search terms
                const searchTerms = searchTerm.toLowerCase().split(' ');
                const searchPhrases = new Set();
                
                // Generate all possible combinations of search terms
                for (let i = 0; i < searchTerms.length; i++) {
                    for (let j = i + 1; j <= searchTerms.length; j++) {
                        const phrase = searchTerms.slice(i, j).join(' ');
                        if (!this.exceptions.has(phrase)) {
                            searchPhrases.add(phrase);
                        }
                    }
                }

                texts.forEach(text => {
                    const cleanedText = text.toLowerCase()
                        .replace(/<[^>]+>/g, '') // Remove HTML tags
                        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '') // Remove punctuation
                        .replace(/\s{2,}/g, ' ') // Remove extra spaces
                        .trim();
                    
                    const words = cleanedText.split(' ');

                    // Single words
                    words.forEach(word => {
                        if (!this.blacklist.has(word) && 
                            word.length > 1 && 
                            (!searchPhrases.has(word) || this.exceptions.has(word))) {
                            frequencies.words.set(word, (frequencies.words.get(word) || 0) + 1);
                        }
                    });

                    // Phrases (2 to maxWords length)
                    for (let length = 2; length <= maxWords; length++) {
                        for (let i = 0; i <= words.length - length; i++) {
                            const phrase = words.slice(i, i + length).join(' ');
                            if (!this.hasBlacklistedWords(phrase) && 
                                !searchPhrases.has(phrase) && 
                                !this.containsSearchPhrase(phrase, searchPhrases)) {
                                frequencies.phrases.set(phrase, (frequencies.phrases.get(phrase) || 0) + 1);
                            }
                        }
                    }
                });

                return this.formatResults(frequencies, minFrequency);
            },

            containsSearchPhrase(phrase, searchPhrases) {
                for (const searchPhrase of searchPhrases) {
                    if (phrase.includes(searchPhrase)) {
                        return true;
                    }
                }
                return false;
            },

            formatResults(frequencies, minFrequency) {
                // First, sort by frequency and filter by minimum frequency
                const formatMap = map => {
                    return Array.from(map.entries())
                        .filter(([, count]) => count >= minFrequency)
                        .sort((a, b) => b[1] - a[1]);
                };

                const singleWords = formatMap(frequencies.words);
                const phrases = formatMap(frequencies.phrases);

                // Filter out subphrases
                const filteredPhrases = phrases.filter(([phrase1, count1]) => {
                    return !phrases.some(([phrase2, count2]) => {
                        if (phrase1 === phrase2) return false;
                        if (phrase2.includes(phrase1) && count2 >= count1) return true;
                        return false;
                    });
                });

                // Filter out single words that appear in phrases with equal or higher frequency
                const filteredWords = singleWords.filter(([word, wordCount]) => {
                    return !filteredPhrases.some(([phrase, phraseCount]) => {
                        return phrase.includes(word) && phraseCount >= wordCount;
                    });
                });

                return {
                    singleWords: filteredWords,
                    phrases: filteredPhrases
                };
            }
        };

        async function preloadQuestions() {
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'alert alert-info text-center';
            loadingIndicator.innerHTML = `
                <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                Loading question database...
            `;
            document.querySelector('.container-fluid').prepend(loadingIndicator);

            try {
                const repositories = ['sets', 'beeSets'];
                allQuestions = [];
                
                // Fetch file lists from both local directories
                const allFiles = await Promise.all(
                    repositories.map(async repo => {
                        const response = await fetch(`/${repo}`);
                        const files = await response.json();
                        return files.map(file => ({
                            name: file,
                            download_url: `/${repo}/${file}`,
                            repo: repo
                        }));
                    })
                ).then(results => results.flat());

                // Fetch all JSON files in parallel
                const questionSets = await Promise.all(
                    allFiles.map(file => 
                        fetch(file.download_url)
                            .then(res => res.json())
                            .then(data => ({
                                data,
                                repo: file.repo,
                                name: file.name
                            }))
                            .catch(err => {
                                console.warn(`Failed to load ${file.name}:`, err);
                                return null;
                            })
                    )
                );

                // Process all successfully loaded question sets
                allQuestions = questionSets
                    .filter(set => set !== null)
                    .flatMap(({data, repo, name}) => 
                        data.tossups.map(q => ({
                            ...q,
                            setName: name.replace('.json', ''),
                            isBeeset: repo === 'beeSets'
                        }))
                    );

                loadingIndicator.remove();
            } catch (error) {
                console.error('Error:', error);
                loadingIndicator.className = 'alert alert-danger text-center';
                loadingIndicator.textContent = 'Error loading questions. Please refresh the page.';
            }
        }

        async function fetchQuestion() {
            try {
                const setType = document.getElementById('setType').value;
                
                // Determine which repositories to fetch from based on setType
                let repositories = [];
                if (setType === 'all' || setType.startsWith('bowl')) {
                    repositories.push('sets');
                }
                if (setType === 'all' || setType.startsWith('bee')) {
                    repositories.push('beeSets');
                }

                let allFiles = [];
                for (const repo of repositories) {
                    const repoUrl = `https://api.github.com/repos/charliechicken/hbNats/contents/${repo}`;
                    const filesResponse = await fetch(repoUrl);
                    const files = await filesResponse.json();
                    
                    // Filter JSON files based on setType
                    const jsonFiles = files
                        .filter(file => file.name.endsWith('.json'))
                        .filter(file => {
                            if (setType === 'all') return true;
                            const isNationals = file.name.toLowerCase().includes('nationals');
                            const isBee = repo === 'beeSets';
                            
                            switch(setType) {
                                case 'bowl-nationals':
                                    return !isBee && isNationals;
                                case 'bowl-regionals':
                                    return !isBee && !isNationals;
                                case 'bee-nationals':
                                    return isBee && isNationals;
                                case 'bee-regionals':
                                    return isBee && !isNationals;
                                default:
                                    return true;
                            }
                        });
                    
                    allFiles.push(...jsonFiles);
                }

                if (allFiles.length === 0) {
                    throw new Error(`No sets found for set type: ${setType}`);
                }
                
                // Get a random file
                const randomFile = allFiles[Math.floor(Math.random() * allFiles.length)];
                const setName = randomFile.name.replace('.json', '');
                
                // Fetch the content of the selected file
                const response = await fetch(randomFile.download_url);
                const data = await response.json();
                
                // Get random question
                let tossups = data.tossups.filter(tossup => tossup.question && tossup.answer);

                // Filter by category if selected
                const categorySelect = document.getElementById('categoryType');
                const selectedCategory = categorySelect.value;

                if (selectedCategory) {
                    tossups = tossups.filter(tossup => {
                        if (!tossup.metadata) return false;
                        return tossup.metadata.toLowerCase().includes(selectedCategory.toLowerCase());
                    });
                    
                    if (tossups.length === 0) {
                        return fetchQuestion();
                    }
                }

                const randomQuestion = tossups[Math.floor(Math.random() * tossups.length)];
                
                currentQuestion = {
                    question: randomQuestion.question,
                    answer: randomQuestion.answer,
                    setName: setName,
                    metadata: randomQuestion.metadata,
                    pdfLink: `https://www.iacompetitions.com/wp-content/uploads/sites/5/2023/08/${setName}.pdf`
                };
                
                const cleanQuestion = currentQuestion.question.replace(/<[^>]+>/g, '');
                words = cleanQuestion.split(/\s+/);
                
                currentIndex = 0;
                document.getElementById('result').innerText = '';
                
                const questionDiv = document.getElementById('question');
                questionDiv.innerHTML = words.map((word, index) => {
                    return `<span class="word hidden">${word}</span>`;
                }).join(' ');
                
                document.getElementById('set-name').innerHTML = `Set: ${currentQuestion.setName} <a href="${currentQuestion.pdfLink}" target="_blank">PDF</a>`;
                startDisplayingWords();
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = `
                    <div class="alert alert-danger">
                        Error loading question. Please try again.
                    </div>`;
            }
        }

        function startDisplayingWords() {
            const sliderValue = document.getElementById('speed').value;
            const speed = 1100 - sliderValue;
            intervalId = setInterval(displayNextWord, speed);
        }

        function displayNextWord() {
            if (currentIndex < words.length) {
                const wordElements = document.querySelectorAll('#question .word');
                wordElements[currentIndex].classList.remove('hidden');
                currentIndex++;
            } else {
                clearInterval(intervalId);
                document.getElementById('next').classList.remove('hidden');
            }
        }

        function disableSubmit() {
            document.getElementById('submit').classList.add('hidden');
            document.getElementById('answer').disabled = true;
        }

        function enableSubmit() {
            document.getElementById('submit').classList.remove('hidden');
            document.getElementById('answer').disabled = false;
        }

        // Update the submit event listener
        document.getElementById('submit').addEventListener('click', async () => {
            const userAnswer = document.getElementById('answer').value.toLowerCase().trim();
            const correctAnswer = currentQuestion.answer;

            // Show all remaining words
            const wordElements = document.querySelectorAll('#question .word');
            wordElements.forEach(element => element.classList.remove('hidden'));

            // Extract all bolded/underlined parts from the answer
            const boldedParts = correctAnswer.match(/<b>.*?<\/b>|<b><u>.*?<\/u><\/b>/g) || [];
            const acceptableAnswers = boldedParts.map(part => 
                part.replace(/<\/?[bu]>/g, '').toLowerCase().trim()
            );

            const isCorrect = acceptableAnswers.some(answer => 
                userAnswer === answer || 
                userAnswer.includes(answer) || 
                answer.includes(userAnswer)
            );

            if (isCorrect) {
                
                if (audioEnabled) {
                    document.getElementById('correctSound').play();
                }
                
                document.getElementById('result').innerHTML = `
                    <div class="alert alert-success">
                        Correct! The answer was: ${correctAnswer.replace(/<b>(.*?)<\/b>/g, '<span class="emphasized">$1</span>')}
                    </div>`;
            } else {

                if (audioEnabled) {
                    document.getElementById('incorrectSound').play();
                }

                document.getElementById('result').innerHTML = `
                    <div class="alert alert-danger">
                        Incorrect. The answer was: ${correctAnswer.replace(/<b>(.*?)<\/b>/g, '<span class="emphasized">$1</span>')}
                    </div>`;
            }
            document.getElementById('answer').style.display = 'none';
            

            document.getElementById('questionHistory').value += 
            `Question: ${currentQuestion.question.replace(/<[^>]+>/g, '')}\n` +
            `Your Answer: ${userAnswer}\n` +
            `Correct Answer: ${correctAnswer.replace(/<[^>]+>/g, '')}\n` +
            `Set: ${currentQuestion.setName}\n\n`;
            document.getElementById('next').classList.remove('hidden');
            disableSubmit();
        });

        // Add 'j' key listener for next question
        document.addEventListener('keydown', (event) => {
            if (event.key === 'j' && !document.getElementById('next').classList.contains('hidden')) {
                document.getElementById('next').click();
            }
        });

        // Update next question event listener
        document.getElementById('next').addEventListener('click', () => {
            document.getElementById('question').innerHTML = '';
            document.getElementById('answer').value = '';
            document.getElementById('next').classList.add('hidden');
            enableSubmit();
            fetchQuestion();
        });

        document.getElementById('answer').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('submit').click();
            }
        });

        document.getElementById('speed').addEventListener('input', (event) => {
            if (intervalId) {
                clearInterval(intervalId);
                const sliderValue = event.target.value;
                const speed = 1100 - sliderValue;
                intervalId = setInterval(displayNextWord, speed);
            }
        });

        // Handle buzz button and spacebar
        function handleBuzz() {
            if (intervalId) {
                clearInterval(intervalId);
                const answerInput = document.getElementById('answer');
                answerInput.disabled = false;
                answerInput.style.display = 'block';
                answerInput.focus();
                document.getElementById('buzz').disabled = true;
                document.getElementById('submit').classList.remove('hidden');
                
                if (audioEnabled) {
                    document.getElementById('buzzSound').play();
                }
                    
            }
        }

        document.getElementById('buzz').addEventListener('click', handleBuzz);

        // Add spacebar listener for buzz
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && !event.repeat && 
                !document.getElementById('answer').matches(':focus') && 
                !document.getElementById('searchModal').classList.contains('show')) {
                event.preventDefault();
                handleBuzz();
            }
        });

        // Reset buzz button on next question
        document.getElementById('next').addEventListener('click', () => {
            document.getElementById('buzz').disabled = false;
            document.getElementById('answer').disabled = true;
        });

        // Fetch a question when the page loads
        fetchQuestion();

        document.getElementById('audioToggle').addEventListener('click', () => {
            audioEnabled = !audioEnabled;
            const button = document.getElementById('audioToggle');
            if (audioEnabled) {
                button.innerHTML = 'ðŸ”Š Audio On';
                button.classList.remove('audio-off');
                button.classList.add('audio-on');
            } else {
                button.innerHTML = 'ðŸ”ˆ Audio Off';
                button.classList.remove('audio-on');
                button.classList.add('audio-off');
            }
        });

        async function searchQuestions() {
            const searchInput = document.getElementById('searchInput').value.trim();
            const searchType = document.querySelector('input[name="searchType"]:checked').value;
            
            if (!searchInput) return;
            
            const searchResults = document.getElementById('searchResults');
            $('#resultsModal').modal('show');
            
            // Split by commas and create RegExp patterns for each group
            const searchTermGroups = searchInput.split(',').map(group => {
                const phrase = group.trim();
                // Escape special regex characters and create word boundary pattern
                const escapedPhrase = phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                return new RegExp(`\\b${escapedPhrase}\\b`, 'i');
            });
            
            matches = allQuestions.filter(q => {
                const questionText = (q.question || '').replace(/<[^>]+>/g, '');
                const answerText = (q.answer || '').replace(/<[^>]+>/g, '');
                
                // Check if ANY of the comma-separated patterns match
                return searchTermGroups.some(pattern => {
                    switch (searchType) {
                        case 'question':
                            return pattern.test(questionText);
                        case 'answer':
                            return pattern.test(answerText);
                        default: // 'both'
                            return pattern.test(questionText) || pattern.test(answerText);
                    }
                });
            });

            selectedQuestions = [...matches];
            updateSelectedCount();
            displaySearchResults(matches);
        }

        // Add debounce function at the top
        let isSubmitting = false;

        async function handleSubmit() {
            if (isSubmitting) return; // Prevent double submission
            isSubmitting = true;
            
            console.log('handleSubmit called');
            const userAnswer = document.getElementById('answer').value.trim();
            const isCorrect = checkAnswer(userAnswer, currentQuestion.answer);
            
            // Add to history without saving progress (checkAnswer handles that)
            addToQuestionHistory(currentQuestion, userAnswer, isCorrect);
            
            // Show next button
            document.getElementById('next').style.display = 'block';
            
            // Reset submission lock after a short delay
            setTimeout(() => {
                isSubmitting = false;
            }, 1000);
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await preloadQuestions();
            
            // Add search input listener
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    searchQuestions();
                }
            });
            
            // Add submit button listener
            const submitButton = document.getElementById('submit');
            submitButton.addEventListener('click', (e) => {
                e.preventDefault();
                handleSubmit();
            });
            
            // Add enter key listener for answer input
            const answerInput = document.getElementById('answer');
            answerInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    handleSubmit();
                }
            });
        });

        function highlightSearchTerms(text, searchTerm) {
            if (!searchTerm) return text;
            const searchTerms = searchTerm.toLowerCase().split(' ').filter(term => term.length > 0);
            
            // Replace HTML tags with placeholders to preserve them
            const placeholders = [];
            const textWithoutTags = text.replace(/<[^>]+>/g, match => {
                placeholders.push(match);
                return `__TAG${placeholders.length - 1}__`;
            });
            
            // Highlight search terms
            let highlightedText = textWithoutTags;
            searchTerms.forEach(term => {
                const regex = new RegExp(term, 'gi');
                highlightedText = highlightedText.replace(regex, match => 
                    `<mark class="search-highlight">${match}</mark>`
                );
            });
            
            // Restore HTML tags
            placeholders.forEach((tag, index) => {
                highlightedText = highlightedText.replace(`__TAG${index}__`, tag);
            });
            
            return highlightedText;
        }

        function showResult(isCorrect, correctAnswer) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `
                <div class="alert ${isCorrect ? 'alert-success' : 'alert-danger'}">
                    <strong>${isCorrect ? 'Correct!' : 'Incorrect.'}</strong><br>
                    Answer: ${correctAnswer}<br>
                    Category: ${currentQuestion.metadata || 'Uncategorized'}<br>
                    Set: ${currentQuestion.setName}
                </div>`;
        }

        function addToQuestionHistory(question, userAnswer, isCorrect) {
            const historyDiv = document.getElementById('questionHistory');
            
            // Show history div if it's the first answer
            if (historyDiv.style.display === 'none') {
                historyDiv.style.display = 'block';
            }
            
            const card = document.createElement('div');
            card.className = `history-card ${isCorrect ? 'correct' : 'incorrect'}`;
            
            // Extract question text properly
            const questionText = typeof question === 'string' ? question : 
                                (question.question || 'Question not available');
            
            // Create PDF link for set name
            const setPdfLink = currentQuestion.setName ? 
                `<a href="https://www.iacompetitions.com/wp-content/uploads/sites/5/2023/08/${currentQuestion.setName}.pdf" 
                    target="_blank" rel="noopener noreferrer">${currentQuestion.setName}</a>` : 
                'Unknown';
            
            card.innerHTML = `
                <div class="question-text">${questionText}</div>
                <div class="answer-section">
                    <div class="metadata">
                        <span class="set-name">Set: ${setPdfLink}</span>
                        <span class="category">Category: ${currentQuestion.metadata || 'Uncategorized'}</span>
                    </div>
                    <div>
                        <span class="user-answer">Your answer: ${userAnswer}</span>
                    </div>
                    <div>
                        <span class="correct-answer">Correct answer: ${currentQuestion.answer.replace(/<\/?[^>]+(>|$)/g, '')}</span>
                    </div>
                </div>
            `;
            
            // Add to beginning of history
            if (historyDiv.firstChild) {
                historyDiv.insertBefore(card, historyDiv.firstChild);
            } else {
                historyDiv.appendChild(card);
            }
            
            // Keep only last 10 questions
            while (historyDiv.children.length > 10) {
                historyDiv.removeChild(historyDiv.lastChild);
            }
        }

        async function handleSignUp() {
    const email = document.getElementById('authEmail').value;
    const password = document.getElementById('authPassword').value;
    const username = document.getElementById('authUsername').value;
    
    if (!username.trim()) {
        alert('Username is required');
        return;
    }
    
    try {
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        const user = userCredential.user;
        
        // Save user data including username
        await window.db.ref("users/" + user.uid).set({
            email: user.email,
            username: username,
            progress: {
                questionsAnswered: 0,
                correctAnswers: 0,
                history: []
            }
        });
        
        $('#authModal').modal('hide');
    } catch (error) {
        alert(`Error: ${error.message}`);
    }
}

        async function handleSignIn() {
            const email = document.getElementById('authEmail').value;
            const password = document.getElementById('authPassword').value;
            
            try {
                await auth.signInWithEmailAndPassword(email, password);
                $('#authModal').modal('hide');
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }

        async function handleSignOut() {
            try {
                await window.auth.signOut();
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }



        function normalizeAnswer(answer) {
            if (!answer) return [];
            
            // Convert to lowercase and remove extra spaces
            answer = answer.toLowerCase().trim();
            
            // Extract bold/underlined text (text between various tags)
            const tagMatches = answer.match(/<[bu]>(.*?)<\/[bu]>|_(.*?)_/g);
            
            if (tagMatches) {
                // Get the emphasized text
                const emphasizedAnswers = tagMatches.map(match => 
                    match.replace(/<[^>]+>|_/g, '').trim()
                );
                
                // Remove all HTML tags for the full answer
                const fullAnswer = answer.replace(/<[^>]+>/g, '').trim()
                    .replace(/[^a-z0-9\s]/g, '')
                    .replace(/\s+/g, ' ');
                    
                // Return both the emphasized parts and the full answer
                return [...new Set([...emphasizedAnswers, fullAnswer])];
            }
            
            // If no tags, just clean and return the full answer
            return [answer.replace(/<[^>]+>/g, '') // Remove all HTML tags
                     .replace(/[^a-z0-9\s]/g, '') // Remove special characters
                     .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                     .trim()];
        }

        function checkAnswer(userAnswer, correctAnswer) {
            console.log('checkAnswer called with:', { userAnswer, correctAnswer });
            
            // If no answer given, count as incorrect
            if (!userAnswer.trim()) {
                if (window.auth?.currentUser) {
                    const questionData = {
                        question: currentQuestion.question,
                        answer: correctAnswer,
                        userAnswer: '',
                        isCorrect: false,
                        timestamp: new Date().toISOString(),
                        setName: currentQuestion.setName || ''
                    };
                    saveUserProgress(questionData);
                }
                showResult(false, correctAnswer);
                return false;
            }
            
            // Normalize both answers
            const normalizedUserAnswer = normalizeAnswer(userAnswer)[0]; // Take first normalized answer
            const acceptedAnswers = normalizeAnswer(correctAnswer);
            
            console.log('Normalized user answer:', normalizedUserAnswer);
            console.log('Accepted answers:', acceptedAnswers);
            
            // Check if user's answer contains any of the accepted answers
            const isCorrect = acceptedAnswers.some(accepted => {
                const cleanAccepted = accepted.toLowerCase().trim();
                return normalizedUserAnswer.includes(cleanAccepted) || 
                       cleanAccepted.includes(normalizedUserAnswer);
            });
            
            console.log('Answer is:', isCorrect ? 'correct' : 'incorrect');
            
            if (window.auth?.currentUser) {
                const questionData = {
                    question: currentQuestion.question,
                    answer: correctAnswer,
                    userAnswer: userAnswer,
                    isCorrect: isCorrect,
                    timestamp: new Date().toISOString(),
                    setName: currentQuestion.setName || ''
                };
                saveUserProgress(questionData);
            }
            
            showResult(isCorrect, correctAnswer);
            return isCorrect;
        }

        async function showLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '<div class="text-center">Loading...</div>';
            
            try {
                const usersRef = window.db.ref('users');
                const snapshot = await usersRef.orderByChild('progress/correctAnswers')
                    .limitToLast(100)
                    .once('value');
                
                const users = [];
                snapshot.forEach(childSnapshot => {
                    const userData = childSnapshot.val();
                    if (userData.username && userData.progress) {
                        users.push({
                            username: userData.username,
                            correctAnswers: userData.progress.correctAnswers || 0
                        });
                    }
                });
                
                // Sort in descending order
                users.sort((a, b) => b.correctAnswers - a.correctAnswers);
                
                // Update the modal content
                leaderboardList.innerHTML = users.map((user, index) => `
                    <div class="list-group-item d-flex justify-content-between align-items-center">
                        <span class="h5 mb-0">
                            <strong>#${index + 1}</strong> ${user.username}
                        </span>
                        <span class="badge bg-info rounded-pill">
                            ${user.correctAnswers} correct
                        </span>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                leaderboardList.innerHTML = '<div class="text-danger">Error loading leaderboard</div>';
            }
            
            $('#leaderboardModal').modal('show');
        }

        document.addEventListener('mouseup', function(e) {
            const selectedText = window.getSelection().toString().trim();
            const searchConfirm = document.getElementById('searchConfirm');
            const isInModal = e.target.closest('.modal') !== null;
            
            // Only proceed if we have selected text
            if (selectedText && selectedText.length > 0) {
                // For modal selections, auto-search if word length > 2
                if (isInModal && selectedText.length > 3) {
                    document.getElementById('searchInput').value = selectedText;
                    searchQuestions();
                    window.getSelection().removeAllRanges();
                    return;
                }
                
                // For main page selections, show confirmation dialog
                if (!isInModal) {
                    if (!searchConfirm) {
                        // Create confirm dialog if it doesn't exist
                        const confirm = document.createElement('div');
                        confirm.id = 'searchConfirm';
                        confirm.className = 'search-confirm';
                        confirm.innerHTML = `
                            <div class="selected-text"></div>
                            <button class="btn btn-primary btn-sm search-yes">Search</button>
                            <button class="btn btn-secondary btn-sm search-no">Cancel</button>
                        `;
                        document.body.appendChild(confirm);
                    }
                    
                    const confirm = document.getElementById('searchConfirm');
                    confirm.querySelector('.selected-text').textContent = `Search for: "${selectedText}"`;
                    
                    // Position the confirm dialog near the mouse
                    confirm.style.left = `${e.pageX}px`;
                    confirm.style.top = `${e.pageY + 20}px`;
                    confirm.style.display = 'block';
                    
                    // Handle search confirmation
                    confirm.querySelector('.search-yes').onclick = function() {
                        document.getElementById('searchInput').value = selectedText;
                        searchQuestions();
                        confirm.style.display = 'none';
                    };
                    
                    // Handle cancellation
                    confirm.querySelector('.search-no').onclick = function() {
                        confirm.style.display = 'none';
                    };
                    
                    // Close if clicked outside
                    document.addEventListener('mousedown', function closeConfirm(e) {
                        if (!confirm.contains(e.target)) {
                            confirm.style.display = 'none';
                            document.removeEventListener('mousedown', closeConfirm);
                        }
                    });
                }
            }
        });

        let selectedQuestions = [];

        function initializeSelectedQuestions(matches) {
            selectedQuestions = [...matches];
            updateSelectedCount();
        }

        function updateSelectedCount() {
            const countElement = document.getElementById('selectedCount');
            countElement.textContent = `${selectedQuestions.length} questions selected`;
        }

        function toggleAllQuestions() {
            const checkboxes = document.querySelectorAll('.question-selector');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(cb => {
                cb.checked = !allChecked;
            });
            
            selectedQuestions = allChecked ? [] : [...matches];
            updateSelectedCount();
        }

        function practiceSelectedQuestions() {
            if (selectedQuestions.length === 0) return;
            
            // Store selected questions for practice
            localStorage.setItem('practiceQuestions', JSON.stringify(selectedQuestions));
            
            // Hide search modal and show practice modal
            $('#resultsModal').modal('hide');
            
            // Start practice with the selected questions directly
            startPractice(selectedQuestions);
        }

        let practiceQuestionIndex = 0;

        function initializePracticeSession() {
            const practiceQuestions = JSON.parse(localStorage.getItem('practiceQuestions'));
            if (!practiceQuestions || practiceQuestions.length === 0) return;
            
            practiceQuestionIndex = 0;
            displayPracticeQuestion(practiceQuestions[practiceQuestionIndex]);
        }

        let practiceWordIndex = 0;
        let practiceWordInterval;
        let practiceWords = [];
        let isPracticeBuzzed = false;

        function displayPracticeQuestion(question) {
            practiceState.words = question.question.split(/\s+/);
            practiceState.wordIndex = 0;
            practiceState.isBuzzed = false;
            
            const practiceDiv = document.createElement('div');
            practiceDiv.innerHTML = `
                <div class="card mb-3">
                    <div class="card-body">
                        <h6 class="card-subtitle mb-2 text-muted">
                            Set: ${question.setName} 
                            (${question.isBeeset ? 'History Bee' : 'History Bowl'})
                        </h6>
                        <div class="mb-3">
                            <label for="practiceSpeed" class="form-label">Reading Speed</label>
                            <input type="range" class="form-range" id="practiceSpeed" 
                                min="100" max="1000" value="${practiceState.speed}">
                        </div>
                        <div id="practiceQuestionDisplay" class="card-text"></div>
                        <div class="mt-3">
                            <input type="text" class="form-control" id="practiceAnswerInput" 
                                placeholder="Your answer..." disabled>
                            <div class="d-flex gap-2 mt-2">
                                <button class="btn btn-danger" id="practiceBuzzBtn">Buzz (space)</button>
                                <button class="btn btn-primary" id="practiceSubmitBtn" disabled>Submit (enter)</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('practiceModalBody').innerHTML = '';
            document.getElementById('practiceModalBody').appendChild(practiceDiv);
            
            setupPracticeListeners();
            startPracticeWords();
        }

        function startPracticeWords() {
            const display = document.getElementById('practiceQuestionDisplay');
            const speedSlider = document.getElementById('practiceSpeed');
            
            clearInterval(practiceState.interval);
            
            // Only clear display and reset index if this is a new question
            if (practiceState.wordIndex === 0) {
                display.innerHTML = '';
            }
            
            // If changing speed mid-question, keep existing words displayed
            if (practiceState.wordIndex > 0) {
                display.innerHTML = practiceState.words.slice(0, practiceState.wordIndex).join(' ') + ' ';
            }
            
            practiceState.interval = setInterval(() => {
                if (practiceState.wordIndex < practiceState.words.length && !practiceState.isBuzzed) {
                    display.innerHTML += practiceState.words[practiceState.wordIndex] + ' ';
                    practiceState.wordIndex++;
                } else if (practiceState.wordIndex >= practiceState.words.length) {
                    clearInterval(practiceState.interval);
                }
            }, 1100 - parseInt(speedSlider.value));
        }

        function checkPracticeAnswer() {
            const practiceQuestions = JSON.parse(localStorage.getItem('practiceQuestions'));
            const currentQuestion = practiceQuestions[practiceQuestionIndex];
            const userAnswer = document.getElementById('practiceAnswer').value.toLowerCase().trim();
            const correctAnswer = currentQuestion.answer.replace(/<[^>]+>/g, '').toLowerCase();
            const speedSlider = document.getElementById('practiceSpeed');
            const currentSpeed = speedSlider.value;
            
            // Show full question with HTML tags
            document.getElementById('practiceQuestionDisplay').innerHTML = currentQuestion.question;
            

            
            document.getElementById('practiceModalBody').appendChild(resultDiv);
            
            // Restore speed slider value
            document.getElementById('practiceSpeed').value = currentSpeed;
        }

        function handlePracticeBuzz() {
            if (practiceState.isBuzzed) return;
            
            practiceState.isBuzzed = true;
            clearInterval(practiceState.interval);
            
            const answerInput = document.getElementById('practiceAnswerInput');
            const submitBtn = document.getElementById('practiceSubmitBtn');
            const buzzBtn = document.getElementById('practiceBuzzBtn');
            
            if (answerInput) answerInput.disabled = false;
            if (submitBtn) submitBtn.disabled = false;
            if (buzzBtn) buzzBtn.disabled = true;
            
            if (answerInput) answerInput.focus();
        }

        // Prevent space from triggering button clicks when typing
        document.addEventListener('keydown', (e) => {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.tagName === 'INPUT' && e.code === 'Space') {
                e.stopPropagation(); // Prevent space from triggering buzz when typing
            }
        });

        function displaySearchResults(matches) {
            const searchResults = document.getElementById('searchResults');
            
            if (matches.length === 0) {
                searchResults.innerHTML = '<div class="alert alert-info">No matches found.</div>';
                return;
            }

            // Frequency analysis section
            const texts = matches.map(q => q.question);
            const searchTerm = document.getElementById('searchInput').value;
            const frequencyResults = wordFrequencyAnalyzer.analyzeFrequency(texts, searchTerm);

            const frequencyHtml = `
                <div class="card frequency-analysis">
                    <div class="card-body">
                        <div class="row g-2">
                            <div class="col-md-6">
                                <h6>Common Words</h6>
                                <ul class="list-unstyled">
                                    ${frequencyResults.singleWords.slice(0, 10).map(([word, count]) => 
                                        `<li><small>${word} <span class="text-muted">(${count})</span></small></li>`
                                    ).join('')}
                                </ul>
                            </div>
                            <div class="col-md-6">
                                <h6>Common Phrases</h6>
                                <ul class="list-unstyled">
                                    ${frequencyResults.phrases.slice(0, 100).map(([phrase, count]) => 
                                        `<li><small>${phrase} <span class="text-muted">(${count})</span></small></li>`
                                    ).join('')}
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Search results section
            const resultsHtml = matches.map((q, index) => `
                <div class="card search-result-card ${q.isBeeset ? 'history-bee' : 'history-bowl'}">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-start">
                            <div class="form-check">
                                <input class="form-check-input question-selector" 
                                    type="checkbox" 
                                    value="${index}" 
                                    id="check-${index}" 
                                    checked>
                                <label class="form-check-label" for="check-${index}">
                                    <small>Select for practice</small>
                                </label>
                            </div>
                            <small class="text-muted">
                                Set: ${q.setName} 
                                (${q.isBeeset ? 'History Bee' : 'History Bowl'})
                            </small>
                        </div>
                        <div class="card-text">
                            ${highlightSearchTerms(q.question, searchTerm)}
                        </div>
                        <div class="card-text mt-2 text-muted">
                            <p>Answer: ${highlightSearchTerms(q.answer, searchTerm)}</p>
                        </div>
                    </div>
                </div>
            `).join('');

            searchResults.innerHTML = frequencyHtml + resultsHtml;
        }

        let practiceState = {
            questions: [],
            currentIndex: 0,
            unseenQuestions: [],
            words: [],
            wordIndex: 0,
            interval: null,
            isBuzzed: false,
            speed: 500 // Add this to track speed across questions
        };

        function initializePracticeQuestions() {
            practiceState.questions = JSON.parse(localStorage.getItem('practiceQuestions'));
            if (!practiceState.questions || practiceState.questions.length === 0) return;
            
            // Initialize unseen questions with all indices
            practiceState.unseenQuestions = [...Array(practiceState.questions.length).keys()];
            
            // Get first random question
            if (practiceState.unseenQuestions.length > 0) {
                const randomIndex = Math.floor(Math.random() * practiceState.unseenQuestions.length);
                practiceState.currentIndex = practiceState.unseenQuestions[randomIndex];
                practiceState.unseenQuestions.splice(randomIndex, 1);
                
                // Show first question
                showPracticeQuestion(practiceState.questions[practiceState.currentIndex]);
            } else {
                console.error('No practice questions available');
            }
        }

        function showPracticeQuestion(question) {
            if (!question) {
                console.error('Invalid question provided');
                return;
            }

            practiceState.words = question.question.split(/\s+/);
            practiceState.wordIndex = 0;
            practiceState.isBuzzed = false;
            
            const questionsRemaining = practiceState.unseenQuestions.length;
            const totalQuestions = practiceState.questions.length;
            
            const practiceDiv = document.createElement('div');
            practiceDiv.innerHTML = `
                <div class="card mb-3">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="card-subtitle mb-0 text-muted">
                                Set: ${question.setName} 
                                (${question.isBeeset ? 'History Bee' : 'History Bowl'})
                            </h6>
                            <span class="badge bg-primary">
                                ${questionsRemaining} question${questionsRemaining !== 1 ? 's' : ''} remaining
                            </span>
                        </div>
                        <div class="mb-3">
                            <label for="practiceSpeed" class="form-label">Reading Speed</label>
                            <input type="range" class="form-range" id="practiceSpeed" 
                                min="100" max="1000" value="${practiceState.speed}">
                        </div>
                        <div id="practiceQuestionDisplay" class="card-text"></div>
                        <div class="mt-3">
                            <input type="text" class="form-control" id="practiceAnswerInput" 
                                placeholder="Your answer..." disabled>
                            <div class="d-flex gap-2 mt-2">
                                <button class="btn btn-danger" id="practiceBuzzBtn">Buzz (space)</button>
                                <button class="btn btn-primary" id="practiceSubmitBtn" disabled>Submit (enter)</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('practiceModalBody').innerHTML = '';
            document.getElementById('practiceModalBody').appendChild(practiceDiv);
            
            setupPracticeListeners();
            startPracticeWords();
        }

        function setupPracticeListeners() {
            document.getElementById('practiceBuzzBtn').onclick = handlePracticeBuzz;
            document.getElementById('practiceSubmitBtn').onclick = submitPracticeAnswer;
            
            const speedSlider = document.getElementById('practiceSpeed');
            speedSlider.addEventListener('input', (e) => {
                practiceState.speed = parseInt(e.target.value); // Save speed to state
                clearInterval(practiceState.interval);
                startPracticeWords(); // This will now continue from current position
            });
            
            document.addEventListener('keydown', handlePracticeKeypress);
        }

        function handlePracticeKeypress(e) {
            if (!document.getElementById('practiceModal').classList.contains('show')) return;
            
            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                if (!practiceState.isBuzzed) handlePracticeBuzz();
            } else if (e.code === 'Enter' && !e.repeat) {
                if (practiceState.isBuzzed) submitPracticeAnswer();
            } else if (e.code === 'KeyJ' && !e.repeat) {
                const nextBtn = document.querySelector('[onclick="goToNextPractice()"]');
                if (nextBtn) goToNextPractice();
            }
        }

        function submitPracticeAnswer() {
            // Add submission lock
            if (practiceState.isSubmitting) return;
            practiceState.isSubmitting = true;

            if (!practiceState.questions || !practiceState.questions[practiceState.currentIndex]) {
                console.error('No current question found');
                practiceState.isSubmitting = false;
                return;
            }

            const question = practiceState.questions[practiceState.currentIndex];
            const userAnswer = document.getElementById('practiceAnswerInput')?.value.toLowerCase().trim() || '';
            const correctAnswer = question.answer.replace(/<[^>]+>/g, '').toLowerCase();
            
            // Clear any existing result divs
            const existingResults = document.querySelectorAll('.practice-result');
            existingResults.forEach(el => el.remove());
            
            // Show full question
            const displayElement = document.getElementById('practiceQuestionDisplay');
            if (displayElement) {
                displayElement.innerHTML = question.question;
            }
            
            const resultDiv = document.createElement('div');
            resultDiv.className = 'practice-result'; // Add class for easy cleanup
            resultDiv.innerHTML = `
                <div class="alert ${userAnswer === correctAnswer ? 'alert-warning' : 'alert-warning'} mt-3">
                    <strong>Correct Answer:</strong> ${question.answer}
                </div>
                <button class="btn btn-primary mt-2" onclick="goToNextPractice()">Next Question (j)</button>
            `;
            
            document.getElementById('practiceModalBody')?.appendChild(resultDiv);

            // Reset submission lock after a delay
            setTimeout(() => {
                practiceState.isSubmitting = false;
            }, 500);
        }

        // Add this function to handle main button states
        function updateMainButtonStates(disable) {
            const mainButtons = ['buzz', 'submit', 'next'].forEach(id => {
                const button = document.getElementById(id);
                if (button) {
                    button.disabled = disable;
                    button.style.opacity = disable ? '0.5' : '1';
                }
            });
        }

        // Main event listener for keyboard shortcuts
        document.addEventListener('keydown', (e) => {
    const practiceModal = document.getElementById('practiceModal');
    const isPracticeModalOpen = practiceModal?.classList.contains('show');
    const searchInput = document.getElementById('searchInput');
    const practiceAnswerInput = document.getElementById('practiceAnswerInput');
    
    // If typing in any input field, allow default behavior
    if (document.activeElement.tagName === 'INPUT') {
        // Only handle Enter for submission in practice mode
        if (isPracticeModalOpen && e.code === 'Enter' && !e.repeat && practiceState.isBuzzed) {
            e.preventDefault();
            submitPracticeAnswer();
        }
        return; // Allow all other keys when typing in inputs
    }
    
    // Handle practice mode shortcuts when not typing
    if (isPracticeModalOpen) {
        if (e.code === 'Space' && !e.repeat) {
            e.preventDefault();
            if (!practiceState.isBuzzed) handlePracticeBuzz();
        } else if (e.code === 'Enter' && !e.repeat) {
            if (practiceState.isBuzzed) submitPracticeAnswer();
        } else if (e.code === 'KeyJ' && !e.repeat) {
            const nextBtn = document.querySelector('[onclick="goToNextPractice()"]');
            if (nextBtn) goToNextPractice();
        }
    }
});


        function goToNextPractice() {
            const nextIndex = getNextPracticeIndex();
            
            if (nextIndex === -1) {
                return; // Practice session complete
            }
            
            practiceState.currentIndex = nextIndex;
            practiceState.isBuzzed = false;
            showPracticeQuestion(practiceState.questions[practiceState.currentIndex]);
        }

        function startPractice(selectedQuestions) {
            if (!selectedQuestions || selectedQuestions.length === 0) {
                console.error('No questions selected for practice');
                return;
            }
            
            // Initialize practice state with selected questions
            practiceState = {
                questions: selectedQuestions,
                currentIndex: 0,
                unseenQuestions: [...Array(selectedQuestions.length).keys()],
                words: [],
                wordIndex: 0,
                interval: null,
                isBuzzed: false,
                speed: document.getElementById('practiceSpeed')?.value || 500
            };

            // Get first random question
            const randomIndex = Math.floor(Math.random() * practiceState.unseenQuestions.length);
            practiceState.currentIndex = practiceState.unseenQuestions[randomIndex];
            practiceState.unseenQuestions.splice(randomIndex, 1);
            
            // Show practice modal
            $('#practiceModal').modal('show');
            
            // Show first question
            showPracticeQuestion(practiceState.questions[practiceState.currentIndex]);
        }

        function handlePracticeClick() {
            const selectedQuestions = JSON.parse(localStorage.getItem('practiceQuestions'));
            if (!selectedQuestions || selectedQuestions.length === 0) {
                alert('Please select questions to practice first');
                return;
            }
            
            $('#resultsModal').modal('hide');
            startPractice(selectedQuestions);
        }

        function getNextPracticeIndex() {
            if (!practiceState.unseenQuestions || practiceState.unseenQuestions.length === 0) {
                // No more unseen questions, practice session complete
                document.getElementById('practiceModalBody').innerHTML = `
                    <div class="alert alert-success">
                        Practice session complete! You've gone through all ${practiceState.questions.length} selected questions.
                    </div>`;
                return -1;
            }
            
            // Get random index from remaining unseen questions
            const randomIndex = Math.floor(Math.random() * practiceState.unseenQuestions.length);
            const nextQuestionIndex = practiceState.unseenQuestions[randomIndex];
            // Remove this index from unseenQuestions
            practiceState.unseenQuestions.splice(randomIndex, 1);
            
            return nextQuestionIndex;
        }
    </script>

    <!-- Search Modal -->
    <div class="modal fade" id="searchModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Search Questions</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <input type="text" id="searchInput" class="form-control" placeholder="Search for terms...">
                    <br>
                    <div class="btn-group btn-group-toggle mb-3" data-toggle="buttons">
                        <label class="btn btn-outline-primary active">
                            <input type="radio" name="searchType" value="both" checked> Both
                        </label>
                        <label class="btn btn-outline-primary">
                            <input type="radio" name="searchType" value="question"> Questions Only
                        </label>
                        <label class="btn btn-outline-primary">
                            <input type="radio" name="searchType" value="answer"> Answers Only
                        </label>
                    </div>
                    <button class="btn btn-primary mt-3" onclick="searchQuestions()">Search</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Modal -->
    <div class="modal fade" id="resultsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Search Results</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div>
                            <button class="btn btn-primary me-2" onclick="practiceSelectedQuestions()">
                                Practice Selected Questions
                            </button>
                            <button class="btn btn-secondary" onclick="toggleAllQuestions()">
                                Toggle Selection
                            </button>
                        </div>
                        <span id="selectedCount" class="text-muted"></span>
                    </div>
                    <div id="searchResults"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div class="modal fade" id="authModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Sign In / Sign Up</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <input type="email" id="authEmail" class="form-control mb-2" placeholder="Email">
                        <input type="password" id="authPassword" class="form-control mb-2" placeholder="Password">
                        <input type="text" id="authUsername" class="form-control mb-2" placeholder="Username">
                        <div class="btn-group w-100">
                            <button onclick="handleSignIn()" class="btn btn-primary">Sign In</button>
                            <button onclick="handleSignUp()" class="btn btn-secondary">Sign Up</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div class="modal fade" id="leaderboardModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Top 100 Players</h5>
                    <button type="button" class="close" data-dismiss="modal">
                        <span>&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div id="leaderboardList" class="list-group">
                        <!-- Leaderboard entries will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Practice Modal -->
    <div class="modal fade practice-modal" id="practiceModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Practice Selected Questions</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="practiceModalBody">
                    <div id="practiceQuestion"></div>
                    <div id="practiceControls" class="mt-3">
                        <button class="btn btn-primary" onclick="nextPracticeQuestion()">Next Question</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
